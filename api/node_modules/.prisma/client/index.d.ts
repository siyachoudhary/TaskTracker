
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Identity
 * 
 */
export type Identity = $Result.DefaultSelection<Prisma.$IdentityPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrgMembership
 * 
 */
export type OrgMembership = $Result.DefaultSelection<Prisma.$OrgMembershipPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamLink
 * 
 */
export type TeamLink = $Result.DefaultSelection<Prisma.$TeamLinkPayload>
/**
 * Model TeamMembership
 * 
 */
export type TeamMembership = $Result.DefaultSelection<Prisma.$TeamMembershipPayload>
/**
 * Model TeamJoinCode
 * 
 */
export type TeamJoinCode = $Result.DefaultSelection<Prisma.$TeamJoinCodePayload>
/**
 * Model OrgJoinCode
 * 
 */
export type OrgJoinCode = $Result.DefaultSelection<Prisma.$OrgJoinCodePayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskAssignment
 * 
 */
export type TaskAssignment = $Result.DefaultSelection<Prisma.$TaskAssignmentPayload>
/**
 * Model TaskNote
 * 
 */
export type TaskNote = $Result.DefaultSelection<Prisma.$TaskNotePayload>
/**
 * Model TaskNoteMention
 * 
 */
export type TaskNoteMention = $Result.DefaultSelection<Prisma.$TaskNoteMentionPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OrgRole: {
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type OrgRole = (typeof OrgRole)[keyof typeof OrgRole]


export const TeamRole: {
  LEADER: 'LEADER',
  MEMBER: 'MEMBER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const TaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  BLOCKED: 'BLOCKED',
  DONE: 'DONE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const CalendarItemType: {
  TASK: 'TASK',
  EVENT: 'EVENT'
};

export type CalendarItemType = (typeof CalendarItemType)[keyof typeof CalendarItemType]

}

export type OrgRole = $Enums.OrgRole

export const OrgRole: typeof $Enums.OrgRole

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type CalendarItemType = $Enums.CalendarItemType

export const CalendarItemType: typeof $Enums.CalendarItemType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identity`: Exposes CRUD operations for the **Identity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identities
    * const identities = await prisma.identity.findMany()
    * ```
    */
  get identity(): Prisma.IdentityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgMembership`: Exposes CRUD operations for the **OrgMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgMemberships
    * const orgMemberships = await prisma.orgMembership.findMany()
    * ```
    */
  get orgMembership(): Prisma.OrgMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamLink`: Exposes CRUD operations for the **TeamLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamLinks
    * const teamLinks = await prisma.teamLink.findMany()
    * ```
    */
  get teamLink(): Prisma.TeamLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMembership`: Exposes CRUD operations for the **TeamMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMemberships
    * const teamMemberships = await prisma.teamMembership.findMany()
    * ```
    */
  get teamMembership(): Prisma.TeamMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamJoinCode`: Exposes CRUD operations for the **TeamJoinCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamJoinCodes
    * const teamJoinCodes = await prisma.teamJoinCode.findMany()
    * ```
    */
  get teamJoinCode(): Prisma.TeamJoinCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgJoinCode`: Exposes CRUD operations for the **OrgJoinCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgJoinCodes
    * const orgJoinCodes = await prisma.orgJoinCode.findMany()
    * ```
    */
  get orgJoinCode(): Prisma.OrgJoinCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignment`: Exposes CRUD operations for the **TaskAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignments
    * const taskAssignments = await prisma.taskAssignment.findMany()
    * ```
    */
  get taskAssignment(): Prisma.TaskAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskNote`: Exposes CRUD operations for the **TaskNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskNotes
    * const taskNotes = await prisma.taskNote.findMany()
    * ```
    */
  get taskNote(): Prisma.TaskNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskNoteMention`: Exposes CRUD operations for the **TaskNoteMention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskNoteMentions
    * const taskNoteMentions = await prisma.taskNoteMention.findMany()
    * ```
    */
  get taskNoteMention(): Prisma.TaskNoteMentionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Identity: 'Identity',
    Organization: 'Organization',
    OrgMembership: 'OrgMembership',
    Team: 'Team',
    TeamLink: 'TeamLink',
    TeamMembership: 'TeamMembership',
    TeamJoinCode: 'TeamJoinCode',
    OrgJoinCode: 'OrgJoinCode',
    Goal: 'Goal',
    Task: 'Task',
    TaskAssignment: 'TaskAssignment',
    TaskNote: 'TaskNote',
    TaskNoteMention: 'TaskNoteMention',
    CalendarEvent: 'CalendarEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "identity" | "organization" | "orgMembership" | "team" | "teamLink" | "teamMembership" | "teamJoinCode" | "orgJoinCode" | "goal" | "task" | "taskAssignment" | "taskNote" | "taskNoteMention" | "calendarEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Identity: {
        payload: Prisma.$IdentityPayload<ExtArgs>
        fields: Prisma.IdentityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          findFirst: {
            args: Prisma.IdentityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          findMany: {
            args: Prisma.IdentityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          create: {
            args: Prisma.IdentityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          createMany: {
            args: Prisma.IdentityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          delete: {
            args: Prisma.IdentityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          update: {
            args: Prisma.IdentityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          deleteMany: {
            args: Prisma.IdentityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdentityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          upsert: {
            args: Prisma.IdentityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          aggregate: {
            args: Prisma.IdentityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentity>
          }
          groupBy: {
            args: Prisma.IdentityGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentityGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentityCountArgs<ExtArgs>
            result: $Utils.Optional<IdentityCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrgMembership: {
        payload: Prisma.$OrgMembershipPayload<ExtArgs>
        fields: Prisma.OrgMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          findFirst: {
            args: Prisma.OrgMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          findMany: {
            args: Prisma.OrgMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>[]
          }
          create: {
            args: Prisma.OrgMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          createMany: {
            args: Prisma.OrgMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>[]
          }
          delete: {
            args: Prisma.OrgMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          update: {
            args: Prisma.OrgMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          deleteMany: {
            args: Prisma.OrgMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>[]
          }
          upsert: {
            args: Prisma.OrgMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>
          }
          aggregate: {
            args: Prisma.OrgMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgMembership>
          }
          groupBy: {
            args: Prisma.OrgMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<OrgMembershipCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamLink: {
        payload: Prisma.$TeamLinkPayload<ExtArgs>
        fields: Prisma.TeamLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          findFirst: {
            args: Prisma.TeamLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          findMany: {
            args: Prisma.TeamLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>[]
          }
          create: {
            args: Prisma.TeamLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          createMany: {
            args: Prisma.TeamLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>[]
          }
          delete: {
            args: Prisma.TeamLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          update: {
            args: Prisma.TeamLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          deleteMany: {
            args: Prisma.TeamLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>[]
          }
          upsert: {
            args: Prisma.TeamLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLinkPayload>
          }
          aggregate: {
            args: Prisma.TeamLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamLink>
          }
          groupBy: {
            args: Prisma.TeamLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamLinkCountArgs<ExtArgs>
            result: $Utils.Optional<TeamLinkCountAggregateOutputType> | number
          }
        }
      }
      TeamMembership: {
        payload: Prisma.$TeamMembershipPayload<ExtArgs>
        fields: Prisma.TeamMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          findFirst: {
            args: Prisma.TeamMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          findMany: {
            args: Prisma.TeamMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          create: {
            args: Prisma.TeamMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          createMany: {
            args: Prisma.TeamMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          delete: {
            args: Prisma.TeamMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          update: {
            args: Prisma.TeamMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          deleteMany: {
            args: Prisma.TeamMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          upsert: {
            args: Prisma.TeamMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          aggregate: {
            args: Prisma.TeamMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMembership>
          }
          groupBy: {
            args: Prisma.TeamMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMembershipCountAggregateOutputType> | number
          }
        }
      }
      TeamJoinCode: {
        payload: Prisma.$TeamJoinCodePayload<ExtArgs>
        fields: Prisma.TeamJoinCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamJoinCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamJoinCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          findFirst: {
            args: Prisma.TeamJoinCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamJoinCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          findMany: {
            args: Prisma.TeamJoinCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>[]
          }
          create: {
            args: Prisma.TeamJoinCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          createMany: {
            args: Prisma.TeamJoinCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamJoinCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>[]
          }
          delete: {
            args: Prisma.TeamJoinCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          update: {
            args: Prisma.TeamJoinCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          deleteMany: {
            args: Prisma.TeamJoinCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamJoinCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamJoinCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>[]
          }
          upsert: {
            args: Prisma.TeamJoinCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinCodePayload>
          }
          aggregate: {
            args: Prisma.TeamJoinCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamJoinCode>
          }
          groupBy: {
            args: Prisma.TeamJoinCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamJoinCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamJoinCodeCountArgs<ExtArgs>
            result: $Utils.Optional<TeamJoinCodeCountAggregateOutputType> | number
          }
        }
      }
      OrgJoinCode: {
        payload: Prisma.$OrgJoinCodePayload<ExtArgs>
        fields: Prisma.OrgJoinCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgJoinCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgJoinCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          findFirst: {
            args: Prisma.OrgJoinCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgJoinCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          findMany: {
            args: Prisma.OrgJoinCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>[]
          }
          create: {
            args: Prisma.OrgJoinCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          createMany: {
            args: Prisma.OrgJoinCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgJoinCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>[]
          }
          delete: {
            args: Prisma.OrgJoinCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          update: {
            args: Prisma.OrgJoinCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          deleteMany: {
            args: Prisma.OrgJoinCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgJoinCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgJoinCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>[]
          }
          upsert: {
            args: Prisma.OrgJoinCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgJoinCodePayload>
          }
          aggregate: {
            args: Prisma.OrgJoinCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgJoinCode>
          }
          groupBy: {
            args: Prisma.OrgJoinCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgJoinCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgJoinCodeCountArgs<ExtArgs>
            result: $Utils.Optional<OrgJoinCodeCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignment: {
        payload: Prisma.$TaskAssignmentPayload<ExtArgs>
        fields: Prisma.TaskAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findMany: {
            args: Prisma.TaskAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          create: {
            args: Prisma.TaskAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          createMany: {
            args: Prisma.TaskAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          update: {
            args: Prisma.TaskAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TaskAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignment>
          }
          groupBy: {
            args: Prisma.TaskAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentCountAggregateOutputType> | number
          }
        }
      }
      TaskNote: {
        payload: Prisma.$TaskNotePayload<ExtArgs>
        fields: Prisma.TaskNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          findFirst: {
            args: Prisma.TaskNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          findMany: {
            args: Prisma.TaskNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          create: {
            args: Prisma.TaskNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          createMany: {
            args: Prisma.TaskNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          delete: {
            args: Prisma.TaskNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          update: {
            args: Prisma.TaskNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          deleteMany: {
            args: Prisma.TaskNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          upsert: {
            args: Prisma.TaskNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          aggregate: {
            args: Prisma.TaskNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskNote>
          }
          groupBy: {
            args: Prisma.TaskNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskNoteCountArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteCountAggregateOutputType> | number
          }
        }
      }
      TaskNoteMention: {
        payload: Prisma.$TaskNoteMentionPayload<ExtArgs>
        fields: Prisma.TaskNoteMentionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskNoteMentionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskNoteMentionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          findFirst: {
            args: Prisma.TaskNoteMentionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskNoteMentionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          findMany: {
            args: Prisma.TaskNoteMentionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>[]
          }
          create: {
            args: Prisma.TaskNoteMentionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          createMany: {
            args: Prisma.TaskNoteMentionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskNoteMentionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>[]
          }
          delete: {
            args: Prisma.TaskNoteMentionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          update: {
            args: Prisma.TaskNoteMentionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          deleteMany: {
            args: Prisma.TaskNoteMentionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskNoteMentionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskNoteMentionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>[]
          }
          upsert: {
            args: Prisma.TaskNoteMentionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNoteMentionPayload>
          }
          aggregate: {
            args: Prisma.TaskNoteMentionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskNoteMention>
          }
          groupBy: {
            args: Prisma.TaskNoteMentionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteMentionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskNoteMentionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteMentionCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    identity?: IdentityOmit
    organization?: OrganizationOmit
    orgMembership?: OrgMembershipOmit
    team?: TeamOmit
    teamLink?: TeamLinkOmit
    teamMembership?: TeamMembershipOmit
    teamJoinCode?: TeamJoinCodeOmit
    orgJoinCode?: OrgJoinCodeOmit
    goal?: GoalOmit
    task?: TaskOmit
    taskAssignment?: TaskAssignmentOmit
    taskNote?: TaskNoteOmit
    taskNoteMention?: TaskNoteMentionOmit
    calendarEvent?: CalendarEventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    identities: number
    memberships: number
    teamMemberships: number
    notes: number
    TaskAssignment: number
    TaskNoteMention: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identities?: boolean | UserCountOutputTypeCountIdentitiesArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    TaskAssignment?: boolean | UserCountOutputTypeCountTaskAssignmentArgs
    TaskNoteMention?: boolean | UserCountOutputTypeCountTaskNoteMentionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIdentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskNoteMentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteMentionWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    memberships: number
    teams: number
    orgJoinCodes: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | OrganizationCountOutputTypeCountMembershipsArgs
    teams?: boolean | OrganizationCountOutputTypeCountTeamsArgs
    orgJoinCodes?: boolean | OrganizationCountOutputTypeCountOrgJoinCodesArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMembershipWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrgJoinCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgJoinCodeWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    memberships: number
    goals: number
    tasks: number
    events: number
    joinCodes: number
    links: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | TeamCountOutputTypeCountMembershipsArgs
    goals?: boolean | TeamCountOutputTypeCountGoalsArgs
    tasks?: boolean | TeamCountOutputTypeCountTasksArgs
    events?: boolean | TeamCountOutputTypeCountEventsArgs
    joinCodes?: boolean | TeamCountOutputTypeCountJoinCodesArgs
    links?: boolean | TeamCountOutputTypeCountLinksArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountJoinCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamJoinCodeWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLinkWhereInput
  }


  /**
   * Count Type GoalCountOutputType
   */

  export type GoalCountOutputType = {
    tasks: number
  }

  export type GoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | GoalCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCountOutputType
     */
    select?: GoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    assignees: number
    notes: number
    calendarEvents: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | TaskCountOutputTypeCountAssigneesArgs
    notes?: boolean | TaskCountOutputTypeCountNotesArgs
    calendarEvents?: boolean | TaskCountOutputTypeCountCalendarEventsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }


  /**
   * Count Type TaskNoteCountOutputType
   */

  export type TaskNoteCountOutputType = {
    mentions: number
  }

  export type TaskNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentions?: boolean | TaskNoteCountOutputTypeCountMentionsArgs
  }

  // Custom InputTypes
  /**
   * TaskNoteCountOutputType without action
   */
  export type TaskNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteCountOutputType
     */
    select?: TaskNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskNoteCountOutputType without action
   */
  export type TaskNoteCountOutputTypeCountMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteMentionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    handle: string | null
    name: string | null
    createdAt: Date | null
    googleEmail: string | null
    googleRefreshToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    handle: string | null
    name: string | null
    createdAt: Date | null
    googleEmail: string | null
    googleRefreshToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    handle: number
    name: number
    createdAt: number
    googleEmail: number
    googleRefreshToken: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    handle?: true
    name?: true
    createdAt?: true
    googleEmail?: true
    googleRefreshToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    handle?: true
    name?: true
    createdAt?: true
    googleEmail?: true
    googleRefreshToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    handle?: true
    name?: true
    createdAt?: true
    googleEmail?: true
    googleRefreshToken?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    handle: string
    name: string | null
    createdAt: Date
    googleEmail: string | null
    googleRefreshToken: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    handle?: boolean
    name?: boolean
    createdAt?: boolean
    googleEmail?: boolean
    googleRefreshToken?: boolean
    identities?: boolean | User$identitiesArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    TaskAssignment?: boolean | User$TaskAssignmentArgs<ExtArgs>
    TaskNoteMention?: boolean | User$TaskNoteMentionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    handle?: boolean
    name?: boolean
    createdAt?: boolean
    googleEmail?: boolean
    googleRefreshToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    handle?: boolean
    name?: boolean
    createdAt?: boolean
    googleEmail?: boolean
    googleRefreshToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    handle?: boolean
    name?: boolean
    createdAt?: boolean
    googleEmail?: boolean
    googleRefreshToken?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "handle" | "name" | "createdAt" | "googleEmail" | "googleRefreshToken", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identities?: boolean | User$identitiesArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    TaskAssignment?: boolean | User$TaskAssignmentArgs<ExtArgs>
    TaskNoteMention?: boolean | User$TaskNoteMentionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      identities: Prisma.$IdentityPayload<ExtArgs>[]
      memberships: Prisma.$OrgMembershipPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMembershipPayload<ExtArgs>[]
      notes: Prisma.$TaskNotePayload<ExtArgs>[]
      TaskAssignment: Prisma.$TaskAssignmentPayload<ExtArgs>[]
      TaskNoteMention: Prisma.$TaskNoteMentionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      handle: string
      name: string | null
      createdAt: Date
      googleEmail: string | null
      googleRefreshToken: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    identities<T extends User$identitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$identitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TaskAssignment<T extends User$TaskAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, User$TaskAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TaskNoteMention<T extends User$TaskNoteMentionArgs<ExtArgs> = {}>(args?: Subset<T, User$TaskNoteMentionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly handle: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly googleEmail: FieldRef<"User", 'String'>
    readonly googleRefreshToken: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.identities
   */
  export type User$identitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    where?: IdentityWhereInput
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    cursor?: IdentityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    where?: OrgMembershipWhereInput
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    cursor?: OrgMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    cursor?: TeamMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    cursor?: TaskNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * User.TaskAssignment
   */
  export type User$TaskAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * User.TaskNoteMention
   */
  export type User$TaskNoteMentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    where?: TaskNoteMentionWhereInput
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    cursor?: TaskNoteMentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteMentionScalarFieldEnum | TaskNoteMentionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Identity
   */

  export type AggregateIdentity = {
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  export type IdentityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerId: string | null
  }

  export type IdentityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerId: string | null
  }

  export type IdentityCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerId: number
    _all: number
  }


  export type IdentityMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
  }

  export type IdentityMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
  }

  export type IdentityCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    _all?: true
  }

  export type IdentityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identity to aggregate.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Identities
    **/
    _count?: true | IdentityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentityMaxAggregateInputType
  }

  export type GetIdentityAggregateType<T extends IdentityAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentity[P]>
      : GetScalarType<T[P], AggregateIdentity[P]>
  }




  export type IdentityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityWhereInput
    orderBy?: IdentityOrderByWithAggregationInput | IdentityOrderByWithAggregationInput[]
    by: IdentityScalarFieldEnum[] | IdentityScalarFieldEnum
    having?: IdentityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentityCountAggregateInputType | true
    _min?: IdentityMinAggregateInputType
    _max?: IdentityMaxAggregateInputType
  }

  export type IdentityGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerId: string
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  type GetIdentityGroupByPayload<T extends IdentityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentityGroupByOutputType[P]>
            : GetScalarType<T[P], IdentityGroupByOutputType[P]>
        }
      >
    >


  export type IdentitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
  }

  export type IdentityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerId", ExtArgs["result"]["identity"]>
  export type IdentityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IdentityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IdentityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IdentityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Identity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerId: string
    }, ExtArgs["result"]["identity"]>
    composites: {}
  }

  type IdentityGetPayload<S extends boolean | null | undefined | IdentityDefaultArgs> = $Result.GetResult<Prisma.$IdentityPayload, S>

  type IdentityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdentityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentityCountAggregateInputType | true
    }

  export interface IdentityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Identity'], meta: { name: 'Identity' } }
    /**
     * Find zero or one Identity that matches the filter.
     * @param {IdentityFindUniqueArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentityFindUniqueArgs>(args: SelectSubset<T, IdentityFindUniqueArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Identity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdentityFindUniqueOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentityFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentityFindFirstArgs>(args?: SelectSubset<T, IdentityFindFirstArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentityFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentityFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identities
     * const identities = await prisma.identity.findMany()
     * 
     * // Get first 10 Identities
     * const identities = await prisma.identity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identityWithIdOnly = await prisma.identity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentityFindManyArgs>(args?: SelectSubset<T, IdentityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Identity.
     * @param {IdentityCreateArgs} args - Arguments to create a Identity.
     * @example
     * // Create one Identity
     * const Identity = await prisma.identity.create({
     *   data: {
     *     // ... data to create a Identity
     *   }
     * })
     * 
     */
    create<T extends IdentityCreateArgs>(args: SelectSubset<T, IdentityCreateArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Identities.
     * @param {IdentityCreateManyArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identity = await prisma.identity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentityCreateManyArgs>(args?: SelectSubset<T, IdentityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Identities and returns the data saved in the database.
     * @param {IdentityCreateManyAndReturnArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identity = await prisma.identity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Identities and only return the `id`
     * const identityWithIdOnly = await prisma.identity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentityCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Identity.
     * @param {IdentityDeleteArgs} args - Arguments to delete one Identity.
     * @example
     * // Delete one Identity
     * const Identity = await prisma.identity.delete({
     *   where: {
     *     // ... filter to delete one Identity
     *   }
     * })
     * 
     */
    delete<T extends IdentityDeleteArgs>(args: SelectSubset<T, IdentityDeleteArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Identity.
     * @param {IdentityUpdateArgs} args - Arguments to update one Identity.
     * @example
     * // Update one Identity
     * const identity = await prisma.identity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentityUpdateArgs>(args: SelectSubset<T, IdentityUpdateArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Identities.
     * @param {IdentityDeleteManyArgs} args - Arguments to filter Identities to delete.
     * @example
     * // Delete a few Identities
     * const { count } = await prisma.identity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentityDeleteManyArgs>(args?: SelectSubset<T, IdentityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identities
     * const identity = await prisma.identity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentityUpdateManyArgs>(args: SelectSubset<T, IdentityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities and returns the data updated in the database.
     * @param {IdentityUpdateManyAndReturnArgs} args - Arguments to update many Identities.
     * @example
     * // Update many Identities
     * const identity = await prisma.identity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Identities and only return the `id`
     * const identityWithIdOnly = await prisma.identity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdentityUpdateManyAndReturnArgs>(args: SelectSubset<T, IdentityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Identity.
     * @param {IdentityUpsertArgs} args - Arguments to update or create a Identity.
     * @example
     * // Update or create a Identity
     * const identity = await prisma.identity.upsert({
     *   create: {
     *     // ... data to create a Identity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identity we want to update
     *   }
     * })
     */
    upsert<T extends IdentityUpsertArgs>(args: SelectSubset<T, IdentityUpsertArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityCountArgs} args - Arguments to filter Identities to count.
     * @example
     * // Count the number of Identities
     * const count = await prisma.identity.count({
     *   where: {
     *     // ... the filter for the Identities we want to count
     *   }
     * })
    **/
    count<T extends IdentityCountArgs>(
      args?: Subset<T, IdentityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentityAggregateArgs>(args: Subset<T, IdentityAggregateArgs>): Prisma.PrismaPromise<GetIdentityAggregateType<T>>

    /**
     * Group by Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentityGroupByArgs['orderBy'] }
        : { orderBy?: IdentityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Identity model
   */
  readonly fields: IdentityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Identity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Identity model
   */
  interface IdentityFieldRefs {
    readonly id: FieldRef<"Identity", 'String'>
    readonly userId: FieldRef<"Identity", 'String'>
    readonly provider: FieldRef<"Identity", 'String'>
    readonly providerId: FieldRef<"Identity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Identity findUnique
   */
  export type IdentityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity findUniqueOrThrow
   */
  export type IdentityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity findFirst
   */
  export type IdentityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity findFirstOrThrow
   */
  export type IdentityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity findMany
   */
  export type IdentityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identities to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity create
   */
  export type IdentityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The data needed to create a Identity.
     */
    data: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
  }

  /**
   * Identity createMany
   */
  export type IdentityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Identities.
     */
    data: IdentityCreateManyInput | IdentityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Identity createManyAndReturn
   */
  export type IdentityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * The data used to create many Identities.
     */
    data: IdentityCreateManyInput | IdentityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Identity update
   */
  export type IdentityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The data needed to update a Identity.
     */
    data: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
    /**
     * Choose, which Identity to update.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity updateMany
   */
  export type IdentityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Identities.
     */
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyInput>
    /**
     * Filter which Identities to update
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to update.
     */
    limit?: number
  }

  /**
   * Identity updateManyAndReturn
   */
  export type IdentityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * The data used to update Identities.
     */
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyInput>
    /**
     * Filter which Identities to update
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Identity upsert
   */
  export type IdentityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The filter to search for the Identity to update in case it exists.
     */
    where: IdentityWhereUniqueInput
    /**
     * In case the Identity found by the `where` argument doesn't exist, create a new Identity with this data.
     */
    create: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
    /**
     * In case the Identity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
  }

  /**
   * Identity delete
   */
  export type IdentityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter which Identity to delete.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity deleteMany
   */
  export type IdentityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identities to delete
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to delete.
     */
    limit?: number
  }

  /**
   * Identity without action
   */
  export type IdentityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    createdBy: string
    createdAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    memberships?: boolean | Organization$membershipsArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    orgJoinCodes?: boolean | Organization$orgJoinCodesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdBy" | "createdAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | Organization$membershipsArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    orgJoinCodes?: boolean | Organization$orgJoinCodesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      memberships: Prisma.$OrgMembershipPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      orgJoinCodes: Prisma.$OrgJoinCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends Organization$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Organization$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orgJoinCodes<T extends Organization$orgJoinCodesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$orgJoinCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly createdBy: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.memberships
   */
  export type Organization$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    where?: OrgMembershipWhereInput
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    cursor?: OrgMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[]
  }

  /**
   * Organization.teams
   */
  export type Organization$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Organization.orgJoinCodes
   */
  export type Organization$orgJoinCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    where?: OrgJoinCodeWhereInput
    orderBy?: OrgJoinCodeOrderByWithRelationInput | OrgJoinCodeOrderByWithRelationInput[]
    cursor?: OrgJoinCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrgJoinCodeScalarFieldEnum | OrgJoinCodeScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrgMembership
   */

  export type AggregateOrgMembership = {
    _count: OrgMembershipCountAggregateOutputType | null
    _min: OrgMembershipMinAggregateOutputType | null
    _max: OrgMembershipMaxAggregateOutputType | null
  }

  export type OrgMembershipMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    role: $Enums.OrgRole | null
  }

  export type OrgMembershipMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    role: $Enums.OrgRole | null
  }

  export type OrgMembershipCountAggregateOutputType = {
    id: number
    orgId: number
    userId: number
    role: number
    _all: number
  }


  export type OrgMembershipMinAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
  }

  export type OrgMembershipMaxAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
  }

  export type OrgMembershipCountAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type OrgMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgMembership to aggregate.
     */
    where?: OrgMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgMemberships
    **/
    _count?: true | OrgMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgMembershipMaxAggregateInputType
  }

  export type GetOrgMembershipAggregateType<T extends OrgMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgMembership[P]>
      : GetScalarType<T[P], AggregateOrgMembership[P]>
  }




  export type OrgMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMembershipWhereInput
    orderBy?: OrgMembershipOrderByWithAggregationInput | OrgMembershipOrderByWithAggregationInput[]
    by: OrgMembershipScalarFieldEnum[] | OrgMembershipScalarFieldEnum
    having?: OrgMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgMembershipCountAggregateInputType | true
    _min?: OrgMembershipMinAggregateInputType
    _max?: OrgMembershipMaxAggregateInputType
  }

  export type OrgMembershipGroupByOutputType = {
    id: string
    orgId: string
    userId: string
    role: $Enums.OrgRole
    _count: OrgMembershipCountAggregateOutputType | null
    _min: OrgMembershipMinAggregateOutputType | null
    _max: OrgMembershipMaxAggregateOutputType | null
  }

  type GetOrgMembershipGroupByPayload<T extends OrgMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], OrgMembershipGroupByOutputType[P]>
        }
      >
    >


  export type OrgMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgMembership"]>

  export type OrgMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgMembership"]>

  export type OrgMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgMembership"]>

  export type OrgMembershipSelectScalar = {
    id?: boolean
    orgId?: boolean
    userId?: boolean
    role?: boolean
  }

  export type OrgMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "userId" | "role", ExtArgs["result"]["orgMembership"]>
  export type OrgMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrgMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrgMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrgMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgMembership"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      userId: string
      role: $Enums.OrgRole
    }, ExtArgs["result"]["orgMembership"]>
    composites: {}
  }

  type OrgMembershipGetPayload<S extends boolean | null | undefined | OrgMembershipDefaultArgs> = $Result.GetResult<Prisma.$OrgMembershipPayload, S>

  type OrgMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgMembershipCountAggregateInputType | true
    }

  export interface OrgMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgMembership'], meta: { name: 'OrgMembership' } }
    /**
     * Find zero or one OrgMembership that matches the filter.
     * @param {OrgMembershipFindUniqueArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgMembershipFindUniqueArgs>(args: SelectSubset<T, OrgMembershipFindUniqueArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrgMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgMembershipFindUniqueOrThrowArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindFirstArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgMembershipFindFirstArgs>(args?: SelectSubset<T, OrgMembershipFindFirstArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindFirstOrThrowArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrgMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgMemberships
     * const orgMemberships = await prisma.orgMembership.findMany()
     * 
     * // Get first 10 OrgMemberships
     * const orgMemberships = await prisma.orgMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgMembershipWithIdOnly = await prisma.orgMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgMembershipFindManyArgs>(args?: SelectSubset<T, OrgMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrgMembership.
     * @param {OrgMembershipCreateArgs} args - Arguments to create a OrgMembership.
     * @example
     * // Create one OrgMembership
     * const OrgMembership = await prisma.orgMembership.create({
     *   data: {
     *     // ... data to create a OrgMembership
     *   }
     * })
     * 
     */
    create<T extends OrgMembershipCreateArgs>(args: SelectSubset<T, OrgMembershipCreateArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrgMemberships.
     * @param {OrgMembershipCreateManyArgs} args - Arguments to create many OrgMemberships.
     * @example
     * // Create many OrgMemberships
     * const orgMembership = await prisma.orgMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgMembershipCreateManyArgs>(args?: SelectSubset<T, OrgMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgMemberships and returns the data saved in the database.
     * @param {OrgMembershipCreateManyAndReturnArgs} args - Arguments to create many OrgMemberships.
     * @example
     * // Create many OrgMemberships
     * const orgMembership = await prisma.orgMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgMemberships and only return the `id`
     * const orgMembershipWithIdOnly = await prisma.orgMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrgMembership.
     * @param {OrgMembershipDeleteArgs} args - Arguments to delete one OrgMembership.
     * @example
     * // Delete one OrgMembership
     * const OrgMembership = await prisma.orgMembership.delete({
     *   where: {
     *     // ... filter to delete one OrgMembership
     *   }
     * })
     * 
     */
    delete<T extends OrgMembershipDeleteArgs>(args: SelectSubset<T, OrgMembershipDeleteArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrgMembership.
     * @param {OrgMembershipUpdateArgs} args - Arguments to update one OrgMembership.
     * @example
     * // Update one OrgMembership
     * const orgMembership = await prisma.orgMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgMembershipUpdateArgs>(args: SelectSubset<T, OrgMembershipUpdateArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrgMemberships.
     * @param {OrgMembershipDeleteManyArgs} args - Arguments to filter OrgMemberships to delete.
     * @example
     * // Delete a few OrgMemberships
     * const { count } = await prisma.orgMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgMembershipDeleteManyArgs>(args?: SelectSubset<T, OrgMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgMemberships
     * const orgMembership = await prisma.orgMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgMembershipUpdateManyArgs>(args: SelectSubset<T, OrgMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgMemberships and returns the data updated in the database.
     * @param {OrgMembershipUpdateManyAndReturnArgs} args - Arguments to update many OrgMemberships.
     * @example
     * // Update many OrgMemberships
     * const orgMembership = await prisma.orgMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrgMemberships and only return the `id`
     * const orgMembershipWithIdOnly = await prisma.orgMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrgMembership.
     * @param {OrgMembershipUpsertArgs} args - Arguments to update or create a OrgMembership.
     * @example
     * // Update or create a OrgMembership
     * const orgMembership = await prisma.orgMembership.upsert({
     *   create: {
     *     // ... data to create a OrgMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgMembership we want to update
     *   }
     * })
     */
    upsert<T extends OrgMembershipUpsertArgs>(args: SelectSubset<T, OrgMembershipUpsertArgs<ExtArgs>>): Prisma__OrgMembershipClient<$Result.GetResult<Prisma.$OrgMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrgMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipCountArgs} args - Arguments to filter OrgMemberships to count.
     * @example
     * // Count the number of OrgMemberships
     * const count = await prisma.orgMembership.count({
     *   where: {
     *     // ... the filter for the OrgMemberships we want to count
     *   }
     * })
    **/
    count<T extends OrgMembershipCountArgs>(
      args?: Subset<T, OrgMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgMembershipAggregateArgs>(args: Subset<T, OrgMembershipAggregateArgs>): Prisma.PrismaPromise<GetOrgMembershipAggregateType<T>>

    /**
     * Group by OrgMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgMembershipGroupByArgs['orderBy'] }
        : { orderBy?: OrgMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgMembership model
   */
  readonly fields: OrgMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgMembership model
   */
  interface OrgMembershipFieldRefs {
    readonly id: FieldRef<"OrgMembership", 'String'>
    readonly orgId: FieldRef<"OrgMembership", 'String'>
    readonly userId: FieldRef<"OrgMembership", 'String'>
    readonly role: FieldRef<"OrgMembership", 'OrgRole'>
  }
    

  // Custom InputTypes
  /**
   * OrgMembership findUnique
   */
  export type OrgMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrgMembership to fetch.
     */
    where: OrgMembershipWhereUniqueInput
  }

  /**
   * OrgMembership findUniqueOrThrow
   */
  export type OrgMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrgMembership to fetch.
     */
    where: OrgMembershipWhereUniqueInput
  }

  /**
   * OrgMembership findFirst
   */
  export type OrgMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrgMembership to fetch.
     */
    where?: OrgMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgMemberships.
     */
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[]
  }

  /**
   * OrgMembership findFirstOrThrow
   */
  export type OrgMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrgMembership to fetch.
     */
    where?: OrgMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgMemberships.
     */
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[]
  }

  /**
   * OrgMembership findMany
   */
  export type OrgMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrgMemberships to fetch.
     */
    where?: OrgMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?: OrgMembershipOrderByWithRelationInput | OrgMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMemberships.
     */
    skip?: number
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[]
  }

  /**
   * OrgMembership create
   */
  export type OrgMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a OrgMembership.
     */
    data: XOR<OrgMembershipCreateInput, OrgMembershipUncheckedCreateInput>
  }

  /**
   * OrgMembership createMany
   */
  export type OrgMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgMemberships.
     */
    data: OrgMembershipCreateManyInput | OrgMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgMembership createManyAndReturn
   */
  export type OrgMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many OrgMemberships.
     */
    data: OrgMembershipCreateManyInput | OrgMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrgMembership update
   */
  export type OrgMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a OrgMembership.
     */
    data: XOR<OrgMembershipUpdateInput, OrgMembershipUncheckedUpdateInput>
    /**
     * Choose, which OrgMembership to update.
     */
    where: OrgMembershipWhereUniqueInput
  }

  /**
   * OrgMembership updateMany
   */
  export type OrgMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgMemberships.
     */
    data: XOR<OrgMembershipUpdateManyMutationInput, OrgMembershipUncheckedUpdateManyInput>
    /**
     * Filter which OrgMemberships to update
     */
    where?: OrgMembershipWhereInput
    /**
     * Limit how many OrgMemberships to update.
     */
    limit?: number
  }

  /**
   * OrgMembership updateManyAndReturn
   */
  export type OrgMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * The data used to update OrgMemberships.
     */
    data: XOR<OrgMembershipUpdateManyMutationInput, OrgMembershipUncheckedUpdateManyInput>
    /**
     * Filter which OrgMemberships to update
     */
    where?: OrgMembershipWhereInput
    /**
     * Limit how many OrgMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrgMembership upsert
   */
  export type OrgMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the OrgMembership to update in case it exists.
     */
    where: OrgMembershipWhereUniqueInput
    /**
     * In case the OrgMembership found by the `where` argument doesn't exist, create a new OrgMembership with this data.
     */
    create: XOR<OrgMembershipCreateInput, OrgMembershipUncheckedCreateInput>
    /**
     * In case the OrgMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgMembershipUpdateInput, OrgMembershipUncheckedUpdateInput>
  }

  /**
   * OrgMembership delete
   */
  export type OrgMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
    /**
     * Filter which OrgMembership to delete.
     */
    where: OrgMembershipWhereUniqueInput
  }

  /**
   * OrgMembership deleteMany
   */
  export type OrgMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgMemberships to delete
     */
    where?: OrgMembershipWhereInput
    /**
     * Limit how many OrgMemberships to delete.
     */
    limit?: number
  }

  /**
   * OrgMembership without action
   */
  export type OrgMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    info: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    info: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    createdBy: number
    createdAt: number
    info: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    createdBy?: true
    createdAt?: true
    info?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    createdBy?: true
    createdAt?: true
    info?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    createdBy?: true
    createdAt?: true
    info?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    orgId: string
    name: string
    createdBy: string
    createdAt: Date
    info: string | null
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    info?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    memberships?: boolean | Team$membershipsArgs<ExtArgs>
    goals?: boolean | Team$goalsArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    events?: boolean | Team$eventsArgs<ExtArgs>
    joinCodes?: boolean | Team$joinCodesArgs<ExtArgs>
    links?: boolean | Team$linksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    info?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    info?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    info?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "createdBy" | "createdAt" | "info", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    memberships?: boolean | Team$membershipsArgs<ExtArgs>
    goals?: boolean | Team$goalsArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    events?: boolean | Team$eventsArgs<ExtArgs>
    joinCodes?: boolean | Team$joinCodesArgs<ExtArgs>
    links?: boolean | Team$linksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      memberships: Prisma.$TeamMembershipPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      events: Prisma.$CalendarEventPayload<ExtArgs>[]
      joinCodes: Prisma.$TeamJoinCodePayload<ExtArgs>[]
      links: Prisma.$TeamLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      createdBy: string
      createdAt: Date
      info: string | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    memberships<T extends Team$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Team$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goals<T extends Team$goalsArgs<ExtArgs> = {}>(args?: Subset<T, Team$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Team$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Team$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Team$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Team$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinCodes<T extends Team$joinCodesArgs<ExtArgs> = {}>(args?: Subset<T, Team$joinCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    links<T extends Team$linksArgs<ExtArgs> = {}>(args?: Subset<T, Team$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly orgId: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly createdBy: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly info: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.memberships
   */
  export type Team$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    cursor?: TeamMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * Team.goals
   */
  export type Team$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Team.tasks
   */
  export type Team$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Team.events
   */
  export type Team$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Team.joinCodes
   */
  export type Team$joinCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    where?: TeamJoinCodeWhereInput
    orderBy?: TeamJoinCodeOrderByWithRelationInput | TeamJoinCodeOrderByWithRelationInput[]
    cursor?: TeamJoinCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamJoinCodeScalarFieldEnum | TeamJoinCodeScalarFieldEnum[]
  }

  /**
   * Team.links
   */
  export type Team$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    where?: TeamLinkWhereInput
    orderBy?: TeamLinkOrderByWithRelationInput | TeamLinkOrderByWithRelationInput[]
    cursor?: TeamLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamLinkScalarFieldEnum | TeamLinkScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamLink
   */

  export type AggregateTeamLink = {
    _count: TeamLinkCountAggregateOutputType | null
    _avg: TeamLinkAvgAggregateOutputType | null
    _sum: TeamLinkSumAggregateOutputType | null
    _min: TeamLinkMinAggregateOutputType | null
    _max: TeamLinkMaxAggregateOutputType | null
  }

  export type TeamLinkAvgAggregateOutputType = {
    ordinal: number | null
  }

  export type TeamLinkSumAggregateOutputType = {
    ordinal: number | null
  }

  export type TeamLinkMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    label: string | null
    url: string | null
    ordinal: number | null
  }

  export type TeamLinkMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    label: string | null
    url: string | null
    ordinal: number | null
  }

  export type TeamLinkCountAggregateOutputType = {
    id: number
    teamId: number
    label: number
    url: number
    ordinal: number
    _all: number
  }


  export type TeamLinkAvgAggregateInputType = {
    ordinal?: true
  }

  export type TeamLinkSumAggregateInputType = {
    ordinal?: true
  }

  export type TeamLinkMinAggregateInputType = {
    id?: true
    teamId?: true
    label?: true
    url?: true
    ordinal?: true
  }

  export type TeamLinkMaxAggregateInputType = {
    id?: true
    teamId?: true
    label?: true
    url?: true
    ordinal?: true
  }

  export type TeamLinkCountAggregateInputType = {
    id?: true
    teamId?: true
    label?: true
    url?: true
    ordinal?: true
    _all?: true
  }

  export type TeamLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLink to aggregate.
     */
    where?: TeamLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLinks to fetch.
     */
    orderBy?: TeamLinkOrderByWithRelationInput | TeamLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamLinks
    **/
    _count?: true | TeamLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamLinkMaxAggregateInputType
  }

  export type GetTeamLinkAggregateType<T extends TeamLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamLink[P]>
      : GetScalarType<T[P], AggregateTeamLink[P]>
  }




  export type TeamLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLinkWhereInput
    orderBy?: TeamLinkOrderByWithAggregationInput | TeamLinkOrderByWithAggregationInput[]
    by: TeamLinkScalarFieldEnum[] | TeamLinkScalarFieldEnum
    having?: TeamLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamLinkCountAggregateInputType | true
    _avg?: TeamLinkAvgAggregateInputType
    _sum?: TeamLinkSumAggregateInputType
    _min?: TeamLinkMinAggregateInputType
    _max?: TeamLinkMaxAggregateInputType
  }

  export type TeamLinkGroupByOutputType = {
    id: string
    teamId: string
    label: string
    url: string
    ordinal: number
    _count: TeamLinkCountAggregateOutputType | null
    _avg: TeamLinkAvgAggregateOutputType | null
    _sum: TeamLinkSumAggregateOutputType | null
    _min: TeamLinkMinAggregateOutputType | null
    _max: TeamLinkMaxAggregateOutputType | null
  }

  type GetTeamLinkGroupByPayload<T extends TeamLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamLinkGroupByOutputType[P]>
            : GetScalarType<T[P], TeamLinkGroupByOutputType[P]>
        }
      >
    >


  export type TeamLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    label?: boolean
    url?: boolean
    ordinal?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLink"]>

  export type TeamLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    label?: boolean
    url?: boolean
    ordinal?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLink"]>

  export type TeamLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    label?: boolean
    url?: boolean
    ordinal?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLink"]>

  export type TeamLinkSelectScalar = {
    id?: boolean
    teamId?: boolean
    label?: boolean
    url?: boolean
    ordinal?: boolean
  }

  export type TeamLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "label" | "url" | "ordinal", ExtArgs["result"]["teamLink"]>
  export type TeamLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamLink"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      label: string
      url: string
      ordinal: number
    }, ExtArgs["result"]["teamLink"]>
    composites: {}
  }

  type TeamLinkGetPayload<S extends boolean | null | undefined | TeamLinkDefaultArgs> = $Result.GetResult<Prisma.$TeamLinkPayload, S>

  type TeamLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamLinkCountAggregateInputType | true
    }

  export interface TeamLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamLink'], meta: { name: 'TeamLink' } }
    /**
     * Find zero or one TeamLink that matches the filter.
     * @param {TeamLinkFindUniqueArgs} args - Arguments to find a TeamLink
     * @example
     * // Get one TeamLink
     * const teamLink = await prisma.teamLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamLinkFindUniqueArgs>(args: SelectSubset<T, TeamLinkFindUniqueArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamLinkFindUniqueOrThrowArgs} args - Arguments to find a TeamLink
     * @example
     * // Get one TeamLink
     * const teamLink = await prisma.teamLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkFindFirstArgs} args - Arguments to find a TeamLink
     * @example
     * // Get one TeamLink
     * const teamLink = await prisma.teamLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamLinkFindFirstArgs>(args?: SelectSubset<T, TeamLinkFindFirstArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkFindFirstOrThrowArgs} args - Arguments to find a TeamLink
     * @example
     * // Get one TeamLink
     * const teamLink = await prisma.teamLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamLinks
     * const teamLinks = await prisma.teamLink.findMany()
     * 
     * // Get first 10 TeamLinks
     * const teamLinks = await prisma.teamLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamLinkWithIdOnly = await prisma.teamLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamLinkFindManyArgs>(args?: SelectSubset<T, TeamLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamLink.
     * @param {TeamLinkCreateArgs} args - Arguments to create a TeamLink.
     * @example
     * // Create one TeamLink
     * const TeamLink = await prisma.teamLink.create({
     *   data: {
     *     // ... data to create a TeamLink
     *   }
     * })
     * 
     */
    create<T extends TeamLinkCreateArgs>(args: SelectSubset<T, TeamLinkCreateArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamLinks.
     * @param {TeamLinkCreateManyArgs} args - Arguments to create many TeamLinks.
     * @example
     * // Create many TeamLinks
     * const teamLink = await prisma.teamLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamLinkCreateManyArgs>(args?: SelectSubset<T, TeamLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamLinks and returns the data saved in the database.
     * @param {TeamLinkCreateManyAndReturnArgs} args - Arguments to create many TeamLinks.
     * @example
     * // Create many TeamLinks
     * const teamLink = await prisma.teamLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamLinks and only return the `id`
     * const teamLinkWithIdOnly = await prisma.teamLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamLink.
     * @param {TeamLinkDeleteArgs} args - Arguments to delete one TeamLink.
     * @example
     * // Delete one TeamLink
     * const TeamLink = await prisma.teamLink.delete({
     *   where: {
     *     // ... filter to delete one TeamLink
     *   }
     * })
     * 
     */
    delete<T extends TeamLinkDeleteArgs>(args: SelectSubset<T, TeamLinkDeleteArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamLink.
     * @param {TeamLinkUpdateArgs} args - Arguments to update one TeamLink.
     * @example
     * // Update one TeamLink
     * const teamLink = await prisma.teamLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamLinkUpdateArgs>(args: SelectSubset<T, TeamLinkUpdateArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamLinks.
     * @param {TeamLinkDeleteManyArgs} args - Arguments to filter TeamLinks to delete.
     * @example
     * // Delete a few TeamLinks
     * const { count } = await prisma.teamLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamLinkDeleteManyArgs>(args?: SelectSubset<T, TeamLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamLinks
     * const teamLink = await prisma.teamLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamLinkUpdateManyArgs>(args: SelectSubset<T, TeamLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLinks and returns the data updated in the database.
     * @param {TeamLinkUpdateManyAndReturnArgs} args - Arguments to update many TeamLinks.
     * @example
     * // Update many TeamLinks
     * const teamLink = await prisma.teamLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamLinks and only return the `id`
     * const teamLinkWithIdOnly = await prisma.teamLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamLink.
     * @param {TeamLinkUpsertArgs} args - Arguments to update or create a TeamLink.
     * @example
     * // Update or create a TeamLink
     * const teamLink = await prisma.teamLink.upsert({
     *   create: {
     *     // ... data to create a TeamLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamLink we want to update
     *   }
     * })
     */
    upsert<T extends TeamLinkUpsertArgs>(args: SelectSubset<T, TeamLinkUpsertArgs<ExtArgs>>): Prisma__TeamLinkClient<$Result.GetResult<Prisma.$TeamLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkCountArgs} args - Arguments to filter TeamLinks to count.
     * @example
     * // Count the number of TeamLinks
     * const count = await prisma.teamLink.count({
     *   where: {
     *     // ... the filter for the TeamLinks we want to count
     *   }
     * })
    **/
    count<T extends TeamLinkCountArgs>(
      args?: Subset<T, TeamLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamLinkAggregateArgs>(args: Subset<T, TeamLinkAggregateArgs>): Prisma.PrismaPromise<GetTeamLinkAggregateType<T>>

    /**
     * Group by TeamLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamLinkGroupByArgs['orderBy'] }
        : { orderBy?: TeamLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamLink model
   */
  readonly fields: TeamLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamLink model
   */
  interface TeamLinkFieldRefs {
    readonly id: FieldRef<"TeamLink", 'String'>
    readonly teamId: FieldRef<"TeamLink", 'String'>
    readonly label: FieldRef<"TeamLink", 'String'>
    readonly url: FieldRef<"TeamLink", 'String'>
    readonly ordinal: FieldRef<"TeamLink", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamLink findUnique
   */
  export type TeamLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamLink to fetch.
     */
    where: TeamLinkWhereUniqueInput
  }

  /**
   * TeamLink findUniqueOrThrow
   */
  export type TeamLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamLink to fetch.
     */
    where: TeamLinkWhereUniqueInput
  }

  /**
   * TeamLink findFirst
   */
  export type TeamLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamLink to fetch.
     */
    where?: TeamLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLinks to fetch.
     */
    orderBy?: TeamLinkOrderByWithRelationInput | TeamLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLinks.
     */
    cursor?: TeamLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLinks.
     */
    distinct?: TeamLinkScalarFieldEnum | TeamLinkScalarFieldEnum[]
  }

  /**
   * TeamLink findFirstOrThrow
   */
  export type TeamLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamLink to fetch.
     */
    where?: TeamLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLinks to fetch.
     */
    orderBy?: TeamLinkOrderByWithRelationInput | TeamLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLinks.
     */
    cursor?: TeamLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLinks.
     */
    distinct?: TeamLinkScalarFieldEnum | TeamLinkScalarFieldEnum[]
  }

  /**
   * TeamLink findMany
   */
  export type TeamLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamLinks to fetch.
     */
    where?: TeamLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLinks to fetch.
     */
    orderBy?: TeamLinkOrderByWithRelationInput | TeamLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamLinks.
     */
    cursor?: TeamLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLinks.
     */
    skip?: number
    distinct?: TeamLinkScalarFieldEnum | TeamLinkScalarFieldEnum[]
  }

  /**
   * TeamLink create
   */
  export type TeamLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamLink.
     */
    data: XOR<TeamLinkCreateInput, TeamLinkUncheckedCreateInput>
  }

  /**
   * TeamLink createMany
   */
  export type TeamLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamLinks.
     */
    data: TeamLinkCreateManyInput | TeamLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamLink createManyAndReturn
   */
  export type TeamLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * The data used to create many TeamLinks.
     */
    data: TeamLinkCreateManyInput | TeamLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLink update
   */
  export type TeamLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamLink.
     */
    data: XOR<TeamLinkUpdateInput, TeamLinkUncheckedUpdateInput>
    /**
     * Choose, which TeamLink to update.
     */
    where: TeamLinkWhereUniqueInput
  }

  /**
   * TeamLink updateMany
   */
  export type TeamLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamLinks.
     */
    data: XOR<TeamLinkUpdateManyMutationInput, TeamLinkUncheckedUpdateManyInput>
    /**
     * Filter which TeamLinks to update
     */
    where?: TeamLinkWhereInput
    /**
     * Limit how many TeamLinks to update.
     */
    limit?: number
  }

  /**
   * TeamLink updateManyAndReturn
   */
  export type TeamLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * The data used to update TeamLinks.
     */
    data: XOR<TeamLinkUpdateManyMutationInput, TeamLinkUncheckedUpdateManyInput>
    /**
     * Filter which TeamLinks to update
     */
    where?: TeamLinkWhereInput
    /**
     * Limit how many TeamLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLink upsert
   */
  export type TeamLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamLink to update in case it exists.
     */
    where: TeamLinkWhereUniqueInput
    /**
     * In case the TeamLink found by the `where` argument doesn't exist, create a new TeamLink with this data.
     */
    create: XOR<TeamLinkCreateInput, TeamLinkUncheckedCreateInput>
    /**
     * In case the TeamLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamLinkUpdateInput, TeamLinkUncheckedUpdateInput>
  }

  /**
   * TeamLink delete
   */
  export type TeamLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
    /**
     * Filter which TeamLink to delete.
     */
    where: TeamLinkWhereUniqueInput
  }

  /**
   * TeamLink deleteMany
   */
  export type TeamLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLinks to delete
     */
    where?: TeamLinkWhereInput
    /**
     * Limit how many TeamLinks to delete.
     */
    limit?: number
  }

  /**
   * TeamLink without action
   */
  export type TeamLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLink
     */
    select?: TeamLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLink
     */
    omit?: TeamLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLinkInclude<ExtArgs> | null
  }


  /**
   * Model TeamMembership
   */

  export type AggregateTeamMembership = {
    _count: TeamMembershipCountAggregateOutputType | null
    _min: TeamMembershipMinAggregateOutputType | null
    _max: TeamMembershipMaxAggregateOutputType | null
  }

  export type TeamMembershipMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
  }

  export type TeamMembershipMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
  }

  export type TeamMembershipCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    _all: number
  }


  export type TeamMembershipMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
  }

  export type TeamMembershipMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
  }

  export type TeamMembershipCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type TeamMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembership to aggregate.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMemberships
    **/
    _count?: true | TeamMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMembershipMaxAggregateInputType
  }

  export type GetTeamMembershipAggregateType<T extends TeamMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMembership[P]>
      : GetScalarType<T[P], AggregateTeamMembership[P]>
  }




  export type TeamMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithAggregationInput | TeamMembershipOrderByWithAggregationInput[]
    by: TeamMembershipScalarFieldEnum[] | TeamMembershipScalarFieldEnum
    having?: TeamMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMembershipCountAggregateInputType | true
    _min?: TeamMembershipMinAggregateInputType
    _max?: TeamMembershipMaxAggregateInputType
  }

  export type TeamMembershipGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    role: $Enums.TeamRole
    _count: TeamMembershipCountAggregateOutputType | null
    _min: TeamMembershipMinAggregateOutputType | null
    _max: TeamMembershipMaxAggregateOutputType | null
  }

  type GetTeamMembershipGroupByPayload<T extends TeamMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMembershipGroupByOutputType[P]>
        }
      >
    >


  export type TeamMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
  }

  export type TeamMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role", ExtArgs["result"]["teamMembership"]>
  export type TeamMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMembership"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      role: $Enums.TeamRole
    }, ExtArgs["result"]["teamMembership"]>
    composites: {}
  }

  type TeamMembershipGetPayload<S extends boolean | null | undefined | TeamMembershipDefaultArgs> = $Result.GetResult<Prisma.$TeamMembershipPayload, S>

  type TeamMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMembershipCountAggregateInputType | true
    }

  export interface TeamMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMembership'], meta: { name: 'TeamMembership' } }
    /**
     * Find zero or one TeamMembership that matches the filter.
     * @param {TeamMembershipFindUniqueArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMembershipFindUniqueArgs>(args: SelectSubset<T, TeamMembershipFindUniqueArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMembershipFindUniqueOrThrowArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindFirstArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMembershipFindFirstArgs>(args?: SelectSubset<T, TeamMembershipFindFirstArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindFirstOrThrowArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany()
     * 
     * // Get first 10 TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMembershipFindManyArgs>(args?: SelectSubset<T, TeamMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMembership.
     * @param {TeamMembershipCreateArgs} args - Arguments to create a TeamMembership.
     * @example
     * // Create one TeamMembership
     * const TeamMembership = await prisma.teamMembership.create({
     *   data: {
     *     // ... data to create a TeamMembership
     *   }
     * })
     * 
     */
    create<T extends TeamMembershipCreateArgs>(args: SelectSubset<T, TeamMembershipCreateArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMemberships.
     * @param {TeamMembershipCreateManyArgs} args - Arguments to create many TeamMemberships.
     * @example
     * // Create many TeamMemberships
     * const teamMembership = await prisma.teamMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMembershipCreateManyArgs>(args?: SelectSubset<T, TeamMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMemberships and returns the data saved in the database.
     * @param {TeamMembershipCreateManyAndReturnArgs} args - Arguments to create many TeamMemberships.
     * @example
     * // Create many TeamMemberships
     * const teamMembership = await prisma.teamMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMemberships and only return the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMembership.
     * @param {TeamMembershipDeleteArgs} args - Arguments to delete one TeamMembership.
     * @example
     * // Delete one TeamMembership
     * const TeamMembership = await prisma.teamMembership.delete({
     *   where: {
     *     // ... filter to delete one TeamMembership
     *   }
     * })
     * 
     */
    delete<T extends TeamMembershipDeleteArgs>(args: SelectSubset<T, TeamMembershipDeleteArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMembership.
     * @param {TeamMembershipUpdateArgs} args - Arguments to update one TeamMembership.
     * @example
     * // Update one TeamMembership
     * const teamMembership = await prisma.teamMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMembershipUpdateArgs>(args: SelectSubset<T, TeamMembershipUpdateArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMemberships.
     * @param {TeamMembershipDeleteManyArgs} args - Arguments to filter TeamMemberships to delete.
     * @example
     * // Delete a few TeamMemberships
     * const { count } = await prisma.teamMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMembershipDeleteManyArgs>(args?: SelectSubset<T, TeamMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMemberships
     * const teamMembership = await prisma.teamMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMembershipUpdateManyArgs>(args: SelectSubset<T, TeamMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMemberships and returns the data updated in the database.
     * @param {TeamMembershipUpdateManyAndReturnArgs} args - Arguments to update many TeamMemberships.
     * @example
     * // Update many TeamMemberships
     * const teamMembership = await prisma.teamMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMemberships and only return the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMembership.
     * @param {TeamMembershipUpsertArgs} args - Arguments to update or create a TeamMembership.
     * @example
     * // Update or create a TeamMembership
     * const teamMembership = await prisma.teamMembership.upsert({
     *   create: {
     *     // ... data to create a TeamMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMembership we want to update
     *   }
     * })
     */
    upsert<T extends TeamMembershipUpsertArgs>(args: SelectSubset<T, TeamMembershipUpsertArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipCountArgs} args - Arguments to filter TeamMemberships to count.
     * @example
     * // Count the number of TeamMemberships
     * const count = await prisma.teamMembership.count({
     *   where: {
     *     // ... the filter for the TeamMemberships we want to count
     *   }
     * })
    **/
    count<T extends TeamMembershipCountArgs>(
      args?: Subset<T, TeamMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMembershipAggregateArgs>(args: Subset<T, TeamMembershipAggregateArgs>): Prisma.PrismaPromise<GetTeamMembershipAggregateType<T>>

    /**
     * Group by TeamMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMembershipGroupByArgs['orderBy'] }
        : { orderBy?: TeamMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMembership model
   */
  readonly fields: TeamMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMembership model
   */
  interface TeamMembershipFieldRefs {
    readonly id: FieldRef<"TeamMembership", 'String'>
    readonly teamId: FieldRef<"TeamMembership", 'String'>
    readonly userId: FieldRef<"TeamMembership", 'String'>
    readonly role: FieldRef<"TeamMembership", 'TeamRole'>
  }
    

  // Custom InputTypes
  /**
   * TeamMembership findUnique
   */
  export type TeamMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership findUniqueOrThrow
   */
  export type TeamMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership findFirst
   */
  export type TeamMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMemberships.
     */
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership findFirstOrThrow
   */
  export type TeamMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMemberships.
     */
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership findMany
   */
  export type TeamMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMemberships to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership create
   */
  export type TeamMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMembership.
     */
    data: XOR<TeamMembershipCreateInput, TeamMembershipUncheckedCreateInput>
  }

  /**
   * TeamMembership createMany
   */
  export type TeamMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMemberships.
     */
    data: TeamMembershipCreateManyInput | TeamMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMembership createManyAndReturn
   */
  export type TeamMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMemberships.
     */
    data: TeamMembershipCreateManyInput | TeamMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMembership update
   */
  export type TeamMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMembership.
     */
    data: XOR<TeamMembershipUpdateInput, TeamMembershipUncheckedUpdateInput>
    /**
     * Choose, which TeamMembership to update.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership updateMany
   */
  export type TeamMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMemberships.
     */
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TeamMemberships to update
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to update.
     */
    limit?: number
  }

  /**
   * TeamMembership updateManyAndReturn
   */
  export type TeamMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * The data used to update TeamMemberships.
     */
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TeamMemberships to update
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMembership upsert
   */
  export type TeamMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMembership to update in case it exists.
     */
    where: TeamMembershipWhereUniqueInput
    /**
     * In case the TeamMembership found by the `where` argument doesn't exist, create a new TeamMembership with this data.
     */
    create: XOR<TeamMembershipCreateInput, TeamMembershipUncheckedCreateInput>
    /**
     * In case the TeamMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMembershipUpdateInput, TeamMembershipUncheckedUpdateInput>
  }

  /**
   * TeamMembership delete
   */
  export type TeamMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter which TeamMembership to delete.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership deleteMany
   */
  export type TeamMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMemberships to delete
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to delete.
     */
    limit?: number
  }

  /**
   * TeamMembership without action
   */
  export type TeamMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
  }


  /**
   * Model TeamJoinCode
   */

  export type AggregateTeamJoinCode = {
    _count: TeamJoinCodeCountAggregateOutputType | null
    _avg: TeamJoinCodeAvgAggregateOutputType | null
    _sum: TeamJoinCodeSumAggregateOutputType | null
    _min: TeamJoinCodeMinAggregateOutputType | null
    _max: TeamJoinCodeMaxAggregateOutputType | null
  }

  export type TeamJoinCodeAvgAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type TeamJoinCodeSumAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type TeamJoinCodeMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    code: string | null
    expiresAt: Date | null
    maxUses: number | null
    uses: number | null
  }

  export type TeamJoinCodeMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    code: string | null
    expiresAt: Date | null
    maxUses: number | null
    uses: number | null
  }

  export type TeamJoinCodeCountAggregateOutputType = {
    id: number
    teamId: number
    code: number
    expiresAt: number
    maxUses: number
    uses: number
    _all: number
  }


  export type TeamJoinCodeAvgAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type TeamJoinCodeSumAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type TeamJoinCodeMinAggregateInputType = {
    id?: true
    teamId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
  }

  export type TeamJoinCodeMaxAggregateInputType = {
    id?: true
    teamId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
  }

  export type TeamJoinCodeCountAggregateInputType = {
    id?: true
    teamId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
    _all?: true
  }

  export type TeamJoinCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamJoinCode to aggregate.
     */
    where?: TeamJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinCodes to fetch.
     */
    orderBy?: TeamJoinCodeOrderByWithRelationInput | TeamJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamJoinCodes
    **/
    _count?: true | TeamJoinCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamJoinCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamJoinCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamJoinCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamJoinCodeMaxAggregateInputType
  }

  export type GetTeamJoinCodeAggregateType<T extends TeamJoinCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamJoinCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamJoinCode[P]>
      : GetScalarType<T[P], AggregateTeamJoinCode[P]>
  }




  export type TeamJoinCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamJoinCodeWhereInput
    orderBy?: TeamJoinCodeOrderByWithAggregationInput | TeamJoinCodeOrderByWithAggregationInput[]
    by: TeamJoinCodeScalarFieldEnum[] | TeamJoinCodeScalarFieldEnum
    having?: TeamJoinCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamJoinCodeCountAggregateInputType | true
    _avg?: TeamJoinCodeAvgAggregateInputType
    _sum?: TeamJoinCodeSumAggregateInputType
    _min?: TeamJoinCodeMinAggregateInputType
    _max?: TeamJoinCodeMaxAggregateInputType
  }

  export type TeamJoinCodeGroupByOutputType = {
    id: string
    teamId: string
    code: string
    expiresAt: Date | null
    maxUses: number | null
    uses: number
    _count: TeamJoinCodeCountAggregateOutputType | null
    _avg: TeamJoinCodeAvgAggregateOutputType | null
    _sum: TeamJoinCodeSumAggregateOutputType | null
    _min: TeamJoinCodeMinAggregateOutputType | null
    _max: TeamJoinCodeMaxAggregateOutputType | null
  }

  type GetTeamJoinCodeGroupByPayload<T extends TeamJoinCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamJoinCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamJoinCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamJoinCodeGroupByOutputType[P]>
            : GetScalarType<T[P], TeamJoinCodeGroupByOutputType[P]>
        }
      >
    >


  export type TeamJoinCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamJoinCode"]>

  export type TeamJoinCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamJoinCode"]>

  export type TeamJoinCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamJoinCode"]>

  export type TeamJoinCodeSelectScalar = {
    id?: boolean
    teamId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
  }

  export type TeamJoinCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "code" | "expiresAt" | "maxUses" | "uses", ExtArgs["result"]["teamJoinCode"]>
  export type TeamJoinCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamJoinCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamJoinCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamJoinCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamJoinCode"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      code: string
      expiresAt: Date | null
      maxUses: number | null
      uses: number
    }, ExtArgs["result"]["teamJoinCode"]>
    composites: {}
  }

  type TeamJoinCodeGetPayload<S extends boolean | null | undefined | TeamJoinCodeDefaultArgs> = $Result.GetResult<Prisma.$TeamJoinCodePayload, S>

  type TeamJoinCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamJoinCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamJoinCodeCountAggregateInputType | true
    }

  export interface TeamJoinCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamJoinCode'], meta: { name: 'TeamJoinCode' } }
    /**
     * Find zero or one TeamJoinCode that matches the filter.
     * @param {TeamJoinCodeFindUniqueArgs} args - Arguments to find a TeamJoinCode
     * @example
     * // Get one TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamJoinCodeFindUniqueArgs>(args: SelectSubset<T, TeamJoinCodeFindUniqueArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamJoinCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamJoinCodeFindUniqueOrThrowArgs} args - Arguments to find a TeamJoinCode
     * @example
     * // Get one TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamJoinCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamJoinCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamJoinCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeFindFirstArgs} args - Arguments to find a TeamJoinCode
     * @example
     * // Get one TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamJoinCodeFindFirstArgs>(args?: SelectSubset<T, TeamJoinCodeFindFirstArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamJoinCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeFindFirstOrThrowArgs} args - Arguments to find a TeamJoinCode
     * @example
     * // Get one TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamJoinCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamJoinCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamJoinCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamJoinCodes
     * const teamJoinCodes = await prisma.teamJoinCode.findMany()
     * 
     * // Get first 10 TeamJoinCodes
     * const teamJoinCodes = await prisma.teamJoinCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamJoinCodeWithIdOnly = await prisma.teamJoinCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamJoinCodeFindManyArgs>(args?: SelectSubset<T, TeamJoinCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamJoinCode.
     * @param {TeamJoinCodeCreateArgs} args - Arguments to create a TeamJoinCode.
     * @example
     * // Create one TeamJoinCode
     * const TeamJoinCode = await prisma.teamJoinCode.create({
     *   data: {
     *     // ... data to create a TeamJoinCode
     *   }
     * })
     * 
     */
    create<T extends TeamJoinCodeCreateArgs>(args: SelectSubset<T, TeamJoinCodeCreateArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamJoinCodes.
     * @param {TeamJoinCodeCreateManyArgs} args - Arguments to create many TeamJoinCodes.
     * @example
     * // Create many TeamJoinCodes
     * const teamJoinCode = await prisma.teamJoinCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamJoinCodeCreateManyArgs>(args?: SelectSubset<T, TeamJoinCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamJoinCodes and returns the data saved in the database.
     * @param {TeamJoinCodeCreateManyAndReturnArgs} args - Arguments to create many TeamJoinCodes.
     * @example
     * // Create many TeamJoinCodes
     * const teamJoinCode = await prisma.teamJoinCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamJoinCodes and only return the `id`
     * const teamJoinCodeWithIdOnly = await prisma.teamJoinCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamJoinCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamJoinCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamJoinCode.
     * @param {TeamJoinCodeDeleteArgs} args - Arguments to delete one TeamJoinCode.
     * @example
     * // Delete one TeamJoinCode
     * const TeamJoinCode = await prisma.teamJoinCode.delete({
     *   where: {
     *     // ... filter to delete one TeamJoinCode
     *   }
     * })
     * 
     */
    delete<T extends TeamJoinCodeDeleteArgs>(args: SelectSubset<T, TeamJoinCodeDeleteArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamJoinCode.
     * @param {TeamJoinCodeUpdateArgs} args - Arguments to update one TeamJoinCode.
     * @example
     * // Update one TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamJoinCodeUpdateArgs>(args: SelectSubset<T, TeamJoinCodeUpdateArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamJoinCodes.
     * @param {TeamJoinCodeDeleteManyArgs} args - Arguments to filter TeamJoinCodes to delete.
     * @example
     * // Delete a few TeamJoinCodes
     * const { count } = await prisma.teamJoinCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamJoinCodeDeleteManyArgs>(args?: SelectSubset<T, TeamJoinCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamJoinCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamJoinCodes
     * const teamJoinCode = await prisma.teamJoinCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamJoinCodeUpdateManyArgs>(args: SelectSubset<T, TeamJoinCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamJoinCodes and returns the data updated in the database.
     * @param {TeamJoinCodeUpdateManyAndReturnArgs} args - Arguments to update many TeamJoinCodes.
     * @example
     * // Update many TeamJoinCodes
     * const teamJoinCode = await prisma.teamJoinCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamJoinCodes and only return the `id`
     * const teamJoinCodeWithIdOnly = await prisma.teamJoinCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamJoinCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamJoinCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamJoinCode.
     * @param {TeamJoinCodeUpsertArgs} args - Arguments to update or create a TeamJoinCode.
     * @example
     * // Update or create a TeamJoinCode
     * const teamJoinCode = await prisma.teamJoinCode.upsert({
     *   create: {
     *     // ... data to create a TeamJoinCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamJoinCode we want to update
     *   }
     * })
     */
    upsert<T extends TeamJoinCodeUpsertArgs>(args: SelectSubset<T, TeamJoinCodeUpsertArgs<ExtArgs>>): Prisma__TeamJoinCodeClient<$Result.GetResult<Prisma.$TeamJoinCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamJoinCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeCountArgs} args - Arguments to filter TeamJoinCodes to count.
     * @example
     * // Count the number of TeamJoinCodes
     * const count = await prisma.teamJoinCode.count({
     *   where: {
     *     // ... the filter for the TeamJoinCodes we want to count
     *   }
     * })
    **/
    count<T extends TeamJoinCodeCountArgs>(
      args?: Subset<T, TeamJoinCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamJoinCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamJoinCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamJoinCodeAggregateArgs>(args: Subset<T, TeamJoinCodeAggregateArgs>): Prisma.PrismaPromise<GetTeamJoinCodeAggregateType<T>>

    /**
     * Group by TeamJoinCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamJoinCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamJoinCodeGroupByArgs['orderBy'] }
        : { orderBy?: TeamJoinCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamJoinCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamJoinCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamJoinCode model
   */
  readonly fields: TeamJoinCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamJoinCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamJoinCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamJoinCode model
   */
  interface TeamJoinCodeFieldRefs {
    readonly id: FieldRef<"TeamJoinCode", 'String'>
    readonly teamId: FieldRef<"TeamJoinCode", 'String'>
    readonly code: FieldRef<"TeamJoinCode", 'String'>
    readonly expiresAt: FieldRef<"TeamJoinCode", 'DateTime'>
    readonly maxUses: FieldRef<"TeamJoinCode", 'Int'>
    readonly uses: FieldRef<"TeamJoinCode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamJoinCode findUnique
   */
  export type TeamJoinCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinCode to fetch.
     */
    where: TeamJoinCodeWhereUniqueInput
  }

  /**
   * TeamJoinCode findUniqueOrThrow
   */
  export type TeamJoinCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinCode to fetch.
     */
    where: TeamJoinCodeWhereUniqueInput
  }

  /**
   * TeamJoinCode findFirst
   */
  export type TeamJoinCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinCode to fetch.
     */
    where?: TeamJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinCodes to fetch.
     */
    orderBy?: TeamJoinCodeOrderByWithRelationInput | TeamJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamJoinCodes.
     */
    cursor?: TeamJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamJoinCodes.
     */
    distinct?: TeamJoinCodeScalarFieldEnum | TeamJoinCodeScalarFieldEnum[]
  }

  /**
   * TeamJoinCode findFirstOrThrow
   */
  export type TeamJoinCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinCode to fetch.
     */
    where?: TeamJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinCodes to fetch.
     */
    orderBy?: TeamJoinCodeOrderByWithRelationInput | TeamJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamJoinCodes.
     */
    cursor?: TeamJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamJoinCodes.
     */
    distinct?: TeamJoinCodeScalarFieldEnum | TeamJoinCodeScalarFieldEnum[]
  }

  /**
   * TeamJoinCode findMany
   */
  export type TeamJoinCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinCodes to fetch.
     */
    where?: TeamJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinCodes to fetch.
     */
    orderBy?: TeamJoinCodeOrderByWithRelationInput | TeamJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamJoinCodes.
     */
    cursor?: TeamJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinCodes.
     */
    skip?: number
    distinct?: TeamJoinCodeScalarFieldEnum | TeamJoinCodeScalarFieldEnum[]
  }

  /**
   * TeamJoinCode create
   */
  export type TeamJoinCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamJoinCode.
     */
    data: XOR<TeamJoinCodeCreateInput, TeamJoinCodeUncheckedCreateInput>
  }

  /**
   * TeamJoinCode createMany
   */
  export type TeamJoinCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamJoinCodes.
     */
    data: TeamJoinCodeCreateManyInput | TeamJoinCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamJoinCode createManyAndReturn
   */
  export type TeamJoinCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * The data used to create many TeamJoinCodes.
     */
    data: TeamJoinCodeCreateManyInput | TeamJoinCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamJoinCode update
   */
  export type TeamJoinCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamJoinCode.
     */
    data: XOR<TeamJoinCodeUpdateInput, TeamJoinCodeUncheckedUpdateInput>
    /**
     * Choose, which TeamJoinCode to update.
     */
    where: TeamJoinCodeWhereUniqueInput
  }

  /**
   * TeamJoinCode updateMany
   */
  export type TeamJoinCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamJoinCodes.
     */
    data: XOR<TeamJoinCodeUpdateManyMutationInput, TeamJoinCodeUncheckedUpdateManyInput>
    /**
     * Filter which TeamJoinCodes to update
     */
    where?: TeamJoinCodeWhereInput
    /**
     * Limit how many TeamJoinCodes to update.
     */
    limit?: number
  }

  /**
   * TeamJoinCode updateManyAndReturn
   */
  export type TeamJoinCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * The data used to update TeamJoinCodes.
     */
    data: XOR<TeamJoinCodeUpdateManyMutationInput, TeamJoinCodeUncheckedUpdateManyInput>
    /**
     * Filter which TeamJoinCodes to update
     */
    where?: TeamJoinCodeWhereInput
    /**
     * Limit how many TeamJoinCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamJoinCode upsert
   */
  export type TeamJoinCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamJoinCode to update in case it exists.
     */
    where: TeamJoinCodeWhereUniqueInput
    /**
     * In case the TeamJoinCode found by the `where` argument doesn't exist, create a new TeamJoinCode with this data.
     */
    create: XOR<TeamJoinCodeCreateInput, TeamJoinCodeUncheckedCreateInput>
    /**
     * In case the TeamJoinCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamJoinCodeUpdateInput, TeamJoinCodeUncheckedUpdateInput>
  }

  /**
   * TeamJoinCode delete
   */
  export type TeamJoinCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
    /**
     * Filter which TeamJoinCode to delete.
     */
    where: TeamJoinCodeWhereUniqueInput
  }

  /**
   * TeamJoinCode deleteMany
   */
  export type TeamJoinCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamJoinCodes to delete
     */
    where?: TeamJoinCodeWhereInput
    /**
     * Limit how many TeamJoinCodes to delete.
     */
    limit?: number
  }

  /**
   * TeamJoinCode without action
   */
  export type TeamJoinCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinCode
     */
    select?: TeamJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamJoinCode
     */
    omit?: TeamJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinCodeInclude<ExtArgs> | null
  }


  /**
   * Model OrgJoinCode
   */

  export type AggregateOrgJoinCode = {
    _count: OrgJoinCodeCountAggregateOutputType | null
    _avg: OrgJoinCodeAvgAggregateOutputType | null
    _sum: OrgJoinCodeSumAggregateOutputType | null
    _min: OrgJoinCodeMinAggregateOutputType | null
    _max: OrgJoinCodeMaxAggregateOutputType | null
  }

  export type OrgJoinCodeAvgAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type OrgJoinCodeSumAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type OrgJoinCodeMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    code: string | null
    expiresAt: Date | null
    maxUses: number | null
    uses: number | null
    createdAt: Date | null
  }

  export type OrgJoinCodeMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    code: string | null
    expiresAt: Date | null
    maxUses: number | null
    uses: number | null
    createdAt: Date | null
  }

  export type OrgJoinCodeCountAggregateOutputType = {
    id: number
    orgId: number
    code: number
    expiresAt: number
    maxUses: number
    uses: number
    createdAt: number
    _all: number
  }


  export type OrgJoinCodeAvgAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type OrgJoinCodeSumAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type OrgJoinCodeMinAggregateInputType = {
    id?: true
    orgId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
    createdAt?: true
  }

  export type OrgJoinCodeMaxAggregateInputType = {
    id?: true
    orgId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
    createdAt?: true
  }

  export type OrgJoinCodeCountAggregateInputType = {
    id?: true
    orgId?: true
    code?: true
    expiresAt?: true
    maxUses?: true
    uses?: true
    createdAt?: true
    _all?: true
  }

  export type OrgJoinCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgJoinCode to aggregate.
     */
    where?: OrgJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgJoinCodes to fetch.
     */
    orderBy?: OrgJoinCodeOrderByWithRelationInput | OrgJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgJoinCodes
    **/
    _count?: true | OrgJoinCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrgJoinCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrgJoinCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgJoinCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgJoinCodeMaxAggregateInputType
  }

  export type GetOrgJoinCodeAggregateType<T extends OrgJoinCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgJoinCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgJoinCode[P]>
      : GetScalarType<T[P], AggregateOrgJoinCode[P]>
  }




  export type OrgJoinCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgJoinCodeWhereInput
    orderBy?: OrgJoinCodeOrderByWithAggregationInput | OrgJoinCodeOrderByWithAggregationInput[]
    by: OrgJoinCodeScalarFieldEnum[] | OrgJoinCodeScalarFieldEnum
    having?: OrgJoinCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgJoinCodeCountAggregateInputType | true
    _avg?: OrgJoinCodeAvgAggregateInputType
    _sum?: OrgJoinCodeSumAggregateInputType
    _min?: OrgJoinCodeMinAggregateInputType
    _max?: OrgJoinCodeMaxAggregateInputType
  }

  export type OrgJoinCodeGroupByOutputType = {
    id: string
    orgId: string
    code: string
    expiresAt: Date | null
    maxUses: number | null
    uses: number
    createdAt: Date
    _count: OrgJoinCodeCountAggregateOutputType | null
    _avg: OrgJoinCodeAvgAggregateOutputType | null
    _sum: OrgJoinCodeSumAggregateOutputType | null
    _min: OrgJoinCodeMinAggregateOutputType | null
    _max: OrgJoinCodeMaxAggregateOutputType | null
  }

  type GetOrgJoinCodeGroupByPayload<T extends OrgJoinCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgJoinCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgJoinCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgJoinCodeGroupByOutputType[P]>
            : GetScalarType<T[P], OrgJoinCodeGroupByOutputType[P]>
        }
      >
    >


  export type OrgJoinCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    createdAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgJoinCode"]>

  export type OrgJoinCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    createdAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgJoinCode"]>

  export type OrgJoinCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    createdAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgJoinCode"]>

  export type OrgJoinCodeSelectScalar = {
    id?: boolean
    orgId?: boolean
    code?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    uses?: boolean
    createdAt?: boolean
  }

  export type OrgJoinCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "code" | "expiresAt" | "maxUses" | "uses" | "createdAt", ExtArgs["result"]["orgJoinCode"]>
  export type OrgJoinCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrgJoinCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrgJoinCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrgJoinCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgJoinCode"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      code: string
      expiresAt: Date | null
      maxUses: number | null
      uses: number
      createdAt: Date
    }, ExtArgs["result"]["orgJoinCode"]>
    composites: {}
  }

  type OrgJoinCodeGetPayload<S extends boolean | null | undefined | OrgJoinCodeDefaultArgs> = $Result.GetResult<Prisma.$OrgJoinCodePayload, S>

  type OrgJoinCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgJoinCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgJoinCodeCountAggregateInputType | true
    }

  export interface OrgJoinCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgJoinCode'], meta: { name: 'OrgJoinCode' } }
    /**
     * Find zero or one OrgJoinCode that matches the filter.
     * @param {OrgJoinCodeFindUniqueArgs} args - Arguments to find a OrgJoinCode
     * @example
     * // Get one OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgJoinCodeFindUniqueArgs>(args: SelectSubset<T, OrgJoinCodeFindUniqueArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrgJoinCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgJoinCodeFindUniqueOrThrowArgs} args - Arguments to find a OrgJoinCode
     * @example
     * // Get one OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgJoinCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgJoinCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgJoinCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeFindFirstArgs} args - Arguments to find a OrgJoinCode
     * @example
     * // Get one OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgJoinCodeFindFirstArgs>(args?: SelectSubset<T, OrgJoinCodeFindFirstArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgJoinCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeFindFirstOrThrowArgs} args - Arguments to find a OrgJoinCode
     * @example
     * // Get one OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgJoinCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgJoinCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrgJoinCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgJoinCodes
     * const orgJoinCodes = await prisma.orgJoinCode.findMany()
     * 
     * // Get first 10 OrgJoinCodes
     * const orgJoinCodes = await prisma.orgJoinCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgJoinCodeWithIdOnly = await prisma.orgJoinCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgJoinCodeFindManyArgs>(args?: SelectSubset<T, OrgJoinCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrgJoinCode.
     * @param {OrgJoinCodeCreateArgs} args - Arguments to create a OrgJoinCode.
     * @example
     * // Create one OrgJoinCode
     * const OrgJoinCode = await prisma.orgJoinCode.create({
     *   data: {
     *     // ... data to create a OrgJoinCode
     *   }
     * })
     * 
     */
    create<T extends OrgJoinCodeCreateArgs>(args: SelectSubset<T, OrgJoinCodeCreateArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrgJoinCodes.
     * @param {OrgJoinCodeCreateManyArgs} args - Arguments to create many OrgJoinCodes.
     * @example
     * // Create many OrgJoinCodes
     * const orgJoinCode = await prisma.orgJoinCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgJoinCodeCreateManyArgs>(args?: SelectSubset<T, OrgJoinCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgJoinCodes and returns the data saved in the database.
     * @param {OrgJoinCodeCreateManyAndReturnArgs} args - Arguments to create many OrgJoinCodes.
     * @example
     * // Create many OrgJoinCodes
     * const orgJoinCode = await prisma.orgJoinCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgJoinCodes and only return the `id`
     * const orgJoinCodeWithIdOnly = await prisma.orgJoinCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgJoinCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgJoinCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrgJoinCode.
     * @param {OrgJoinCodeDeleteArgs} args - Arguments to delete one OrgJoinCode.
     * @example
     * // Delete one OrgJoinCode
     * const OrgJoinCode = await prisma.orgJoinCode.delete({
     *   where: {
     *     // ... filter to delete one OrgJoinCode
     *   }
     * })
     * 
     */
    delete<T extends OrgJoinCodeDeleteArgs>(args: SelectSubset<T, OrgJoinCodeDeleteArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrgJoinCode.
     * @param {OrgJoinCodeUpdateArgs} args - Arguments to update one OrgJoinCode.
     * @example
     * // Update one OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgJoinCodeUpdateArgs>(args: SelectSubset<T, OrgJoinCodeUpdateArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrgJoinCodes.
     * @param {OrgJoinCodeDeleteManyArgs} args - Arguments to filter OrgJoinCodes to delete.
     * @example
     * // Delete a few OrgJoinCodes
     * const { count } = await prisma.orgJoinCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgJoinCodeDeleteManyArgs>(args?: SelectSubset<T, OrgJoinCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgJoinCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgJoinCodes
     * const orgJoinCode = await prisma.orgJoinCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgJoinCodeUpdateManyArgs>(args: SelectSubset<T, OrgJoinCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgJoinCodes and returns the data updated in the database.
     * @param {OrgJoinCodeUpdateManyAndReturnArgs} args - Arguments to update many OrgJoinCodes.
     * @example
     * // Update many OrgJoinCodes
     * const orgJoinCode = await prisma.orgJoinCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrgJoinCodes and only return the `id`
     * const orgJoinCodeWithIdOnly = await prisma.orgJoinCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgJoinCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgJoinCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrgJoinCode.
     * @param {OrgJoinCodeUpsertArgs} args - Arguments to update or create a OrgJoinCode.
     * @example
     * // Update or create a OrgJoinCode
     * const orgJoinCode = await prisma.orgJoinCode.upsert({
     *   create: {
     *     // ... data to create a OrgJoinCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgJoinCode we want to update
     *   }
     * })
     */
    upsert<T extends OrgJoinCodeUpsertArgs>(args: SelectSubset<T, OrgJoinCodeUpsertArgs<ExtArgs>>): Prisma__OrgJoinCodeClient<$Result.GetResult<Prisma.$OrgJoinCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrgJoinCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeCountArgs} args - Arguments to filter OrgJoinCodes to count.
     * @example
     * // Count the number of OrgJoinCodes
     * const count = await prisma.orgJoinCode.count({
     *   where: {
     *     // ... the filter for the OrgJoinCodes we want to count
     *   }
     * })
    **/
    count<T extends OrgJoinCodeCountArgs>(
      args?: Subset<T, OrgJoinCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgJoinCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgJoinCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgJoinCodeAggregateArgs>(args: Subset<T, OrgJoinCodeAggregateArgs>): Prisma.PrismaPromise<GetOrgJoinCodeAggregateType<T>>

    /**
     * Group by OrgJoinCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgJoinCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgJoinCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgJoinCodeGroupByArgs['orderBy'] }
        : { orderBy?: OrgJoinCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgJoinCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgJoinCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgJoinCode model
   */
  readonly fields: OrgJoinCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgJoinCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgJoinCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgJoinCode model
   */
  interface OrgJoinCodeFieldRefs {
    readonly id: FieldRef<"OrgJoinCode", 'String'>
    readonly orgId: FieldRef<"OrgJoinCode", 'String'>
    readonly code: FieldRef<"OrgJoinCode", 'String'>
    readonly expiresAt: FieldRef<"OrgJoinCode", 'DateTime'>
    readonly maxUses: FieldRef<"OrgJoinCode", 'Int'>
    readonly uses: FieldRef<"OrgJoinCode", 'Int'>
    readonly createdAt: FieldRef<"OrgJoinCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrgJoinCode findUnique
   */
  export type OrgJoinCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which OrgJoinCode to fetch.
     */
    where: OrgJoinCodeWhereUniqueInput
  }

  /**
   * OrgJoinCode findUniqueOrThrow
   */
  export type OrgJoinCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which OrgJoinCode to fetch.
     */
    where: OrgJoinCodeWhereUniqueInput
  }

  /**
   * OrgJoinCode findFirst
   */
  export type OrgJoinCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which OrgJoinCode to fetch.
     */
    where?: OrgJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgJoinCodes to fetch.
     */
    orderBy?: OrgJoinCodeOrderByWithRelationInput | OrgJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgJoinCodes.
     */
    cursor?: OrgJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgJoinCodes.
     */
    distinct?: OrgJoinCodeScalarFieldEnum | OrgJoinCodeScalarFieldEnum[]
  }

  /**
   * OrgJoinCode findFirstOrThrow
   */
  export type OrgJoinCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which OrgJoinCode to fetch.
     */
    where?: OrgJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgJoinCodes to fetch.
     */
    orderBy?: OrgJoinCodeOrderByWithRelationInput | OrgJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgJoinCodes.
     */
    cursor?: OrgJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgJoinCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgJoinCodes.
     */
    distinct?: OrgJoinCodeScalarFieldEnum | OrgJoinCodeScalarFieldEnum[]
  }

  /**
   * OrgJoinCode findMany
   */
  export type OrgJoinCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter, which OrgJoinCodes to fetch.
     */
    where?: OrgJoinCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgJoinCodes to fetch.
     */
    orderBy?: OrgJoinCodeOrderByWithRelationInput | OrgJoinCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgJoinCodes.
     */
    cursor?: OrgJoinCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgJoinCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgJoinCodes.
     */
    skip?: number
    distinct?: OrgJoinCodeScalarFieldEnum | OrgJoinCodeScalarFieldEnum[]
  }

  /**
   * OrgJoinCode create
   */
  export type OrgJoinCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a OrgJoinCode.
     */
    data: XOR<OrgJoinCodeCreateInput, OrgJoinCodeUncheckedCreateInput>
  }

  /**
   * OrgJoinCode createMany
   */
  export type OrgJoinCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgJoinCodes.
     */
    data: OrgJoinCodeCreateManyInput | OrgJoinCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgJoinCode createManyAndReturn
   */
  export type OrgJoinCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * The data used to create many OrgJoinCodes.
     */
    data: OrgJoinCodeCreateManyInput | OrgJoinCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrgJoinCode update
   */
  export type OrgJoinCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a OrgJoinCode.
     */
    data: XOR<OrgJoinCodeUpdateInput, OrgJoinCodeUncheckedUpdateInput>
    /**
     * Choose, which OrgJoinCode to update.
     */
    where: OrgJoinCodeWhereUniqueInput
  }

  /**
   * OrgJoinCode updateMany
   */
  export type OrgJoinCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgJoinCodes.
     */
    data: XOR<OrgJoinCodeUpdateManyMutationInput, OrgJoinCodeUncheckedUpdateManyInput>
    /**
     * Filter which OrgJoinCodes to update
     */
    where?: OrgJoinCodeWhereInput
    /**
     * Limit how many OrgJoinCodes to update.
     */
    limit?: number
  }

  /**
   * OrgJoinCode updateManyAndReturn
   */
  export type OrgJoinCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * The data used to update OrgJoinCodes.
     */
    data: XOR<OrgJoinCodeUpdateManyMutationInput, OrgJoinCodeUncheckedUpdateManyInput>
    /**
     * Filter which OrgJoinCodes to update
     */
    where?: OrgJoinCodeWhereInput
    /**
     * Limit how many OrgJoinCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrgJoinCode upsert
   */
  export type OrgJoinCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the OrgJoinCode to update in case it exists.
     */
    where: OrgJoinCodeWhereUniqueInput
    /**
     * In case the OrgJoinCode found by the `where` argument doesn't exist, create a new OrgJoinCode with this data.
     */
    create: XOR<OrgJoinCodeCreateInput, OrgJoinCodeUncheckedCreateInput>
    /**
     * In case the OrgJoinCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgJoinCodeUpdateInput, OrgJoinCodeUncheckedUpdateInput>
  }

  /**
   * OrgJoinCode delete
   */
  export type OrgJoinCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
    /**
     * Filter which OrgJoinCode to delete.
     */
    where: OrgJoinCodeWhereUniqueInput
  }

  /**
   * OrgJoinCode deleteMany
   */
  export type OrgJoinCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgJoinCodes to delete
     */
    where?: OrgJoinCodeWhereInput
    /**
     * Limit how many OrgJoinCodes to delete.
     */
    limit?: number
  }

  /**
   * OrgJoinCode without action
   */
  export type OrgJoinCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgJoinCode
     */
    select?: OrgJoinCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgJoinCode
     */
    omit?: OrgJoinCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgJoinCodeInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    status: string | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    status: string | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    teamId: number
    title: number
    description: number
    dueDate: number
    status: number
    _all: number
  }


  export type GoalMinAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    teamId: string
    title: string
    description: string | null
    dueDate: Date | null
    status: string
    _count: GoalCountAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    tasks?: boolean | Goal$tasksArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
  }

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "title" | "description" | "dueDate" | "status", ExtArgs["result"]["goal"]>
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    tasks?: boolean | Goal$tasksArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type GoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      title: string
      description: string | null
      dueDate: Date | null
      status: string
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals and returns the data updated in the database.
     * @param {GoalUpdateManyAndReturnArgs} args - Arguments to update many Goals.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Goal$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Goal$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly teamId: FieldRef<"Goal", 'String'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly dueDate: FieldRef<"Goal", 'DateTime'>
    readonly status: FieldRef<"Goal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
  }

  /**
   * Goal updateManyAndReturn
   */
  export type GoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to delete.
     */
    limit?: number
  }

  /**
   * Goal.tasks
   */
  export type Goal$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    goalId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    goalId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    teamId: number
    goalId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    teamId?: true
    goalId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    createdBy?: true
    createdAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    teamId?: true
    goalId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    createdBy?: true
    createdAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    teamId?: true
    goalId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    teamId: string
    goalId: string | null
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.Priority
    dueDate: Date | null
    createdBy: string
    createdAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    notes?: boolean | Task$notesArgs<ExtArgs>
    calendarEvents?: boolean | Task$calendarEventsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    teamId?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "goalId" | "title" | "description" | "status" | "priority" | "dueDate" | "createdBy" | "createdAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    notes?: boolean | Task$notesArgs<ExtArgs>
    calendarEvents?: boolean | Task$calendarEventsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      goal: Prisma.$GoalPayload<ExtArgs> | null
      assignees: Prisma.$TaskAssignmentPayload<ExtArgs>[]
      notes: Prisma.$TaskNotePayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      goalId: string | null
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.Priority
      dueDate: Date | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    goal<T extends Task$goalArgs<ExtArgs> = {}>(args?: Subset<T, Task$goalArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignees<T extends Task$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Task$notesArgs<ExtArgs> = {}>(args?: Subset<T, Task$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarEvents<T extends Task$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, Task$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly teamId: FieldRef<"Task", 'String'>
    readonly goalId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly createdBy: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.goal
   */
  export type Task$goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
  }

  /**
   * Task.assignees
   */
  export type Task$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * Task.notes
   */
  export type Task$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    cursor?: TaskNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * Task.calendarEvents
   */
  export type Task$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignment
   */

  export type AggregateTaskAssignment = {
    _count: TaskAssignmentCountAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  export type TaskAssignmentMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
  }

  export type TaskAssignmentMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
  }

  export type TaskAssignmentCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    _all: number
  }


  export type TaskAssignmentMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssignmentMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssignmentCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    _all?: true
  }

  export type TaskAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignment to aggregate.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignments
    **/
    _count?: true | TaskAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type GetTaskAssignmentAggregateType<T extends TaskAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignment[P]>
      : GetScalarType<T[P], AggregateTaskAssignment[P]>
  }




  export type TaskAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithAggregationInput | TaskAssignmentOrderByWithAggregationInput[]
    by: TaskAssignmentScalarFieldEnum[] | TaskAssignmentScalarFieldEnum
    having?: TaskAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssignmentCountAggregateInputType | true
    _min?: TaskAssignmentMinAggregateInputType
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type TaskAssignmentGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    _count: TaskAssignmentCountAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  type GetTaskAssignmentGroupByPayload<T extends TaskAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
  }

  export type TaskAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId", ExtArgs["result"]["taskAssignment"]>
  export type TaskAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
    }, ExtArgs["result"]["taskAssignment"]>
    composites: {}
  }

  type TaskAssignmentGetPayload<S extends boolean | null | undefined | TaskAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAssignmentPayload, S>

  type TaskAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssignmentCountAggregateInputType | true
    }

  export interface TaskAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignment'], meta: { name: 'TaskAssignment' } }
    /**
     * Find zero or one TaskAssignment that matches the filter.
     * @param {TaskAssignmentFindUniqueArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssignmentFindUniqueArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssignmentFindFirstArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany()
     * 
     * // Get first 10 TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssignmentFindManyArgs>(args?: SelectSubset<T, TaskAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignment.
     * @param {TaskAssignmentCreateArgs} args - Arguments to create a TaskAssignment.
     * @example
     * // Create one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.create({
     *   data: {
     *     // ... data to create a TaskAssignment
     *   }
     * })
     * 
     */
    create<T extends TaskAssignmentCreateArgs>(args: SelectSubset<T, TaskAssignmentCreateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignments.
     * @param {TaskAssignmentCreateManyArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssignmentCreateManyArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignments and returns the data saved in the database.
     * @param {TaskAssignmentCreateManyAndReturnArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignments and only return the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAssignment.
     * @param {TaskAssignmentDeleteArgs} args - Arguments to delete one TaskAssignment.
     * @example
     * // Delete one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignment
     *   }
     * })
     * 
     */
    delete<T extends TaskAssignmentDeleteArgs>(args: SelectSubset<T, TaskAssignmentDeleteArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignment.
     * @param {TaskAssignmentUpdateArgs} args - Arguments to update one TaskAssignment.
     * @example
     * // Update one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssignmentUpdateArgs>(args: SelectSubset<T, TaskAssignmentUpdateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignments.
     * @param {TaskAssignmentDeleteManyArgs} args - Arguments to filter TaskAssignments to delete.
     * @example
     * // Delete a few TaskAssignments
     * const { count } = await prisma.taskAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssignmentDeleteManyArgs>(args?: SelectSubset<T, TaskAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssignmentUpdateManyArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments and returns the data updated in the database.
     * @param {TaskAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TaskAssignments.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAssignments and only return the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAssignment.
     * @param {TaskAssignmentUpsertArgs} args - Arguments to update or create a TaskAssignment.
     * @example
     * // Update or create a TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.upsert({
     *   create: {
     *     // ... data to create a TaskAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssignmentUpsertArgs>(args: SelectSubset<T, TaskAssignmentUpsertArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentCountArgs} args - Arguments to filter TaskAssignments to count.
     * @example
     * // Count the number of TaskAssignments
     * const count = await prisma.taskAssignment.count({
     *   where: {
     *     // ... the filter for the TaskAssignments we want to count
     *   }
     * })
    **/
    count<T extends TaskAssignmentCountArgs>(
      args?: Subset<T, TaskAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssignmentAggregateArgs>(args: Subset<T, TaskAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAssignmentAggregateType<T>>

    /**
     * Group by TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignment model
   */
  readonly fields: TaskAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignment model
   */
  interface TaskAssignmentFieldRefs {
    readonly id: FieldRef<"TaskAssignment", 'String'>
    readonly taskId: FieldRef<"TaskAssignment", 'String'>
    readonly userId: FieldRef<"TaskAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignment findUnique
   */
  export type TaskAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findUniqueOrThrow
   */
  export type TaskAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findFirst
   */
  export type TaskAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findFirstOrThrow
   */
  export type TaskAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findMany
   */
  export type TaskAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignments to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment create
   */
  export type TaskAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignment.
     */
    data: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
  }

  /**
   * TaskAssignment createMany
   */
  export type TaskAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignment createManyAndReturn
   */
  export type TaskAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment update
   */
  export type TaskAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignment.
     */
    data: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignment to update.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment updateMany
   */
  export type TaskAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to update.
     */
    limit?: number
  }

  /**
   * TaskAssignment updateManyAndReturn
   */
  export type TaskAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment upsert
   */
  export type TaskAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignment to update in case it exists.
     */
    where: TaskAssignmentWhereUniqueInput
    /**
     * In case the TaskAssignment found by the `where` argument doesn't exist, create a new TaskAssignment with this data.
     */
    create: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
    /**
     * In case the TaskAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
  }

  /**
   * TaskAssignment delete
   */
  export type TaskAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignment to delete.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment deleteMany
   */
  export type TaskAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignments to delete
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignment without action
   */
  export type TaskAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskNote
   */

  export type AggregateTaskNote = {
    _count: TaskNoteCountAggregateOutputType | null
    _min: TaskNoteMinAggregateOutputType | null
    _max: TaskNoteMaxAggregateOutputType | null
  }

  export type TaskNoteMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TaskNoteMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TaskNoteCountAggregateOutputType = {
    id: number
    taskId: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type TaskNoteMinAggregateInputType = {
    id?: true
    taskId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type TaskNoteMaxAggregateInputType = {
    id?: true
    taskId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type TaskNoteCountAggregateInputType = {
    id?: true
    taskId?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type TaskNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNote to aggregate.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskNotes
    **/
    _count?: true | TaskNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskNoteMaxAggregateInputType
  }

  export type GetTaskNoteAggregateType<T extends TaskNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskNote[P]>
      : GetScalarType<T[P], AggregateTaskNote[P]>
  }




  export type TaskNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithAggregationInput | TaskNoteOrderByWithAggregationInput[]
    by: TaskNoteScalarFieldEnum[] | TaskNoteScalarFieldEnum
    having?: TaskNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskNoteCountAggregateInputType | true
    _min?: TaskNoteMinAggregateInputType
    _max?: TaskNoteMaxAggregateInputType
  }

  export type TaskNoteGroupByOutputType = {
    id: string
    taskId: string
    authorId: string
    content: string
    createdAt: Date
    _count: TaskNoteCountAggregateOutputType | null
    _min: TaskNoteMinAggregateOutputType | null
    _max: TaskNoteMaxAggregateOutputType | null
  }

  type GetTaskNoteGroupByPayload<T extends TaskNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskNoteGroupByOutputType[P]>
            : GetScalarType<T[P], TaskNoteGroupByOutputType[P]>
        }
      >
    >


  export type TaskNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    mentions?: boolean | TaskNote$mentionsArgs<ExtArgs>
    _count?: boolean | TaskNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectScalar = {
    id?: boolean
    taskId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type TaskNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "authorId" | "content" | "createdAt", ExtArgs["result"]["taskNote"]>
  export type TaskNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    mentions?: boolean | TaskNote$mentionsArgs<ExtArgs>
    _count?: boolean | TaskNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskNote"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      mentions: Prisma.$TaskNoteMentionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      authorId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["taskNote"]>
    composites: {}
  }

  type TaskNoteGetPayload<S extends boolean | null | undefined | TaskNoteDefaultArgs> = $Result.GetResult<Prisma.$TaskNotePayload, S>

  type TaskNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskNoteCountAggregateInputType | true
    }

  export interface TaskNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskNote'], meta: { name: 'TaskNote' } }
    /**
     * Find zero or one TaskNote that matches the filter.
     * @param {TaskNoteFindUniqueArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskNoteFindUniqueArgs>(args: SelectSubset<T, TaskNoteFindUniqueArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskNoteFindUniqueOrThrowArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindFirstArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskNoteFindFirstArgs>(args?: SelectSubset<T, TaskNoteFindFirstArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindFirstOrThrowArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskNotes
     * const taskNotes = await prisma.taskNote.findMany()
     * 
     * // Get first 10 TaskNotes
     * const taskNotes = await prisma.taskNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskNoteFindManyArgs>(args?: SelectSubset<T, TaskNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskNote.
     * @param {TaskNoteCreateArgs} args - Arguments to create a TaskNote.
     * @example
     * // Create one TaskNote
     * const TaskNote = await prisma.taskNote.create({
     *   data: {
     *     // ... data to create a TaskNote
     *   }
     * })
     * 
     */
    create<T extends TaskNoteCreateArgs>(args: SelectSubset<T, TaskNoteCreateArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskNotes.
     * @param {TaskNoteCreateManyArgs} args - Arguments to create many TaskNotes.
     * @example
     * // Create many TaskNotes
     * const taskNote = await prisma.taskNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskNoteCreateManyArgs>(args?: SelectSubset<T, TaskNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskNotes and returns the data saved in the database.
     * @param {TaskNoteCreateManyAndReturnArgs} args - Arguments to create many TaskNotes.
     * @example
     * // Create many TaskNotes
     * const taskNote = await prisma.taskNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskNotes and only return the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskNote.
     * @param {TaskNoteDeleteArgs} args - Arguments to delete one TaskNote.
     * @example
     * // Delete one TaskNote
     * const TaskNote = await prisma.taskNote.delete({
     *   where: {
     *     // ... filter to delete one TaskNote
     *   }
     * })
     * 
     */
    delete<T extends TaskNoteDeleteArgs>(args: SelectSubset<T, TaskNoteDeleteArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskNote.
     * @param {TaskNoteUpdateArgs} args - Arguments to update one TaskNote.
     * @example
     * // Update one TaskNote
     * const taskNote = await prisma.taskNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskNoteUpdateArgs>(args: SelectSubset<T, TaskNoteUpdateArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskNotes.
     * @param {TaskNoteDeleteManyArgs} args - Arguments to filter TaskNotes to delete.
     * @example
     * // Delete a few TaskNotes
     * const { count } = await prisma.taskNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskNoteDeleteManyArgs>(args?: SelectSubset<T, TaskNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskNotes
     * const taskNote = await prisma.taskNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskNoteUpdateManyArgs>(args: SelectSubset<T, TaskNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotes and returns the data updated in the database.
     * @param {TaskNoteUpdateManyAndReturnArgs} args - Arguments to update many TaskNotes.
     * @example
     * // Update many TaskNotes
     * const taskNote = await prisma.taskNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskNotes and only return the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskNote.
     * @param {TaskNoteUpsertArgs} args - Arguments to update or create a TaskNote.
     * @example
     * // Update or create a TaskNote
     * const taskNote = await prisma.taskNote.upsert({
     *   create: {
     *     // ... data to create a TaskNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskNote we want to update
     *   }
     * })
     */
    upsert<T extends TaskNoteUpsertArgs>(args: SelectSubset<T, TaskNoteUpsertArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteCountArgs} args - Arguments to filter TaskNotes to count.
     * @example
     * // Count the number of TaskNotes
     * const count = await prisma.taskNote.count({
     *   where: {
     *     // ... the filter for the TaskNotes we want to count
     *   }
     * })
    **/
    count<T extends TaskNoteCountArgs>(
      args?: Subset<T, TaskNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskNoteAggregateArgs>(args: Subset<T, TaskNoteAggregateArgs>): Prisma.PrismaPromise<GetTaskNoteAggregateType<T>>

    /**
     * Group by TaskNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskNoteGroupByArgs['orderBy'] }
        : { orderBy?: TaskNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskNote model
   */
  readonly fields: TaskNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mentions<T extends TaskNote$mentionsArgs<ExtArgs> = {}>(args?: Subset<T, TaskNote$mentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskNote model
   */
  interface TaskNoteFieldRefs {
    readonly id: FieldRef<"TaskNote", 'String'>
    readonly taskId: FieldRef<"TaskNote", 'String'>
    readonly authorId: FieldRef<"TaskNote", 'String'>
    readonly content: FieldRef<"TaskNote", 'String'>
    readonly createdAt: FieldRef<"TaskNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskNote findUnique
   */
  export type TaskNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote findUniqueOrThrow
   */
  export type TaskNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote findFirst
   */
  export type TaskNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotes.
     */
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote findFirstOrThrow
   */
  export type TaskNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotes.
     */
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote findMany
   */
  export type TaskNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotes to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote create
   */
  export type TaskNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskNote.
     */
    data: XOR<TaskNoteCreateInput, TaskNoteUncheckedCreateInput>
  }

  /**
   * TaskNote createMany
   */
  export type TaskNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskNotes.
     */
    data: TaskNoteCreateManyInput | TaskNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskNote createManyAndReturn
   */
  export type TaskNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * The data used to create many TaskNotes.
     */
    data: TaskNoteCreateManyInput | TaskNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNote update
   */
  export type TaskNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskNote.
     */
    data: XOR<TaskNoteUpdateInput, TaskNoteUncheckedUpdateInput>
    /**
     * Choose, which TaskNote to update.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote updateMany
   */
  export type TaskNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskNotes.
     */
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotes to update
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to update.
     */
    limit?: number
  }

  /**
   * TaskNote updateManyAndReturn
   */
  export type TaskNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * The data used to update TaskNotes.
     */
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotes to update
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNote upsert
   */
  export type TaskNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskNote to update in case it exists.
     */
    where: TaskNoteWhereUniqueInput
    /**
     * In case the TaskNote found by the `where` argument doesn't exist, create a new TaskNote with this data.
     */
    create: XOR<TaskNoteCreateInput, TaskNoteUncheckedCreateInput>
    /**
     * In case the TaskNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskNoteUpdateInput, TaskNoteUncheckedUpdateInput>
  }

  /**
   * TaskNote delete
   */
  export type TaskNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter which TaskNote to delete.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote deleteMany
   */
  export type TaskNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNotes to delete
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to delete.
     */
    limit?: number
  }

  /**
   * TaskNote.mentions
   */
  export type TaskNote$mentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    where?: TaskNoteMentionWhereInput
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    cursor?: TaskNoteMentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteMentionScalarFieldEnum | TaskNoteMentionScalarFieldEnum[]
  }

  /**
   * TaskNote without action
   */
  export type TaskNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
  }


  /**
   * Model TaskNoteMention
   */

  export type AggregateTaskNoteMention = {
    _count: TaskNoteMentionCountAggregateOutputType | null
    _min: TaskNoteMentionMinAggregateOutputType | null
    _max: TaskNoteMentionMaxAggregateOutputType | null
  }

  export type TaskNoteMentionMinAggregateOutputType = {
    id: string | null
    noteId: string | null
    userId: string | null
  }

  export type TaskNoteMentionMaxAggregateOutputType = {
    id: string | null
    noteId: string | null
    userId: string | null
  }

  export type TaskNoteMentionCountAggregateOutputType = {
    id: number
    noteId: number
    userId: number
    _all: number
  }


  export type TaskNoteMentionMinAggregateInputType = {
    id?: true
    noteId?: true
    userId?: true
  }

  export type TaskNoteMentionMaxAggregateInputType = {
    id?: true
    noteId?: true
    userId?: true
  }

  export type TaskNoteMentionCountAggregateInputType = {
    id?: true
    noteId?: true
    userId?: true
    _all?: true
  }

  export type TaskNoteMentionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNoteMention to aggregate.
     */
    where?: TaskNoteMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNoteMentions to fetch.
     */
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskNoteMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNoteMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNoteMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskNoteMentions
    **/
    _count?: true | TaskNoteMentionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskNoteMentionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskNoteMentionMaxAggregateInputType
  }

  export type GetTaskNoteMentionAggregateType<T extends TaskNoteMentionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskNoteMention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskNoteMention[P]>
      : GetScalarType<T[P], AggregateTaskNoteMention[P]>
  }




  export type TaskNoteMentionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteMentionWhereInput
    orderBy?: TaskNoteMentionOrderByWithAggregationInput | TaskNoteMentionOrderByWithAggregationInput[]
    by: TaskNoteMentionScalarFieldEnum[] | TaskNoteMentionScalarFieldEnum
    having?: TaskNoteMentionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskNoteMentionCountAggregateInputType | true
    _min?: TaskNoteMentionMinAggregateInputType
    _max?: TaskNoteMentionMaxAggregateInputType
  }

  export type TaskNoteMentionGroupByOutputType = {
    id: string
    noteId: string
    userId: string
    _count: TaskNoteMentionCountAggregateOutputType | null
    _min: TaskNoteMentionMinAggregateOutputType | null
    _max: TaskNoteMentionMaxAggregateOutputType | null
  }

  type GetTaskNoteMentionGroupByPayload<T extends TaskNoteMentionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskNoteMentionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskNoteMentionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskNoteMentionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskNoteMentionGroupByOutputType[P]>
        }
      >
    >


  export type TaskNoteMentionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    userId?: boolean
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNoteMention"]>

  export type TaskNoteMentionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    userId?: boolean
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNoteMention"]>

  export type TaskNoteMentionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    userId?: boolean
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNoteMention"]>

  export type TaskNoteMentionSelectScalar = {
    id?: boolean
    noteId?: boolean
    userId?: boolean
  }

  export type TaskNoteMentionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noteId" | "userId", ExtArgs["result"]["taskNoteMention"]>
  export type TaskNoteMentionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNoteMentionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNoteMentionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | TaskNoteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskNoteMentionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskNoteMention"
    objects: {
      note: Prisma.$TaskNotePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      noteId: string
      userId: string
    }, ExtArgs["result"]["taskNoteMention"]>
    composites: {}
  }

  type TaskNoteMentionGetPayload<S extends boolean | null | undefined | TaskNoteMentionDefaultArgs> = $Result.GetResult<Prisma.$TaskNoteMentionPayload, S>

  type TaskNoteMentionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskNoteMentionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskNoteMentionCountAggregateInputType | true
    }

  export interface TaskNoteMentionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskNoteMention'], meta: { name: 'TaskNoteMention' } }
    /**
     * Find zero or one TaskNoteMention that matches the filter.
     * @param {TaskNoteMentionFindUniqueArgs} args - Arguments to find a TaskNoteMention
     * @example
     * // Get one TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskNoteMentionFindUniqueArgs>(args: SelectSubset<T, TaskNoteMentionFindUniqueArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskNoteMention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskNoteMentionFindUniqueOrThrowArgs} args - Arguments to find a TaskNoteMention
     * @example
     * // Get one TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskNoteMentionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskNoteMentionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNoteMention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionFindFirstArgs} args - Arguments to find a TaskNoteMention
     * @example
     * // Get one TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskNoteMentionFindFirstArgs>(args?: SelectSubset<T, TaskNoteMentionFindFirstArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNoteMention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionFindFirstOrThrowArgs} args - Arguments to find a TaskNoteMention
     * @example
     * // Get one TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskNoteMentionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskNoteMentionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskNoteMentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskNoteMentions
     * const taskNoteMentions = await prisma.taskNoteMention.findMany()
     * 
     * // Get first 10 TaskNoteMentions
     * const taskNoteMentions = await prisma.taskNoteMention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskNoteMentionWithIdOnly = await prisma.taskNoteMention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskNoteMentionFindManyArgs>(args?: SelectSubset<T, TaskNoteMentionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskNoteMention.
     * @param {TaskNoteMentionCreateArgs} args - Arguments to create a TaskNoteMention.
     * @example
     * // Create one TaskNoteMention
     * const TaskNoteMention = await prisma.taskNoteMention.create({
     *   data: {
     *     // ... data to create a TaskNoteMention
     *   }
     * })
     * 
     */
    create<T extends TaskNoteMentionCreateArgs>(args: SelectSubset<T, TaskNoteMentionCreateArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskNoteMentions.
     * @param {TaskNoteMentionCreateManyArgs} args - Arguments to create many TaskNoteMentions.
     * @example
     * // Create many TaskNoteMentions
     * const taskNoteMention = await prisma.taskNoteMention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskNoteMentionCreateManyArgs>(args?: SelectSubset<T, TaskNoteMentionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskNoteMentions and returns the data saved in the database.
     * @param {TaskNoteMentionCreateManyAndReturnArgs} args - Arguments to create many TaskNoteMentions.
     * @example
     * // Create many TaskNoteMentions
     * const taskNoteMention = await prisma.taskNoteMention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskNoteMentions and only return the `id`
     * const taskNoteMentionWithIdOnly = await prisma.taskNoteMention.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskNoteMentionCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskNoteMentionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskNoteMention.
     * @param {TaskNoteMentionDeleteArgs} args - Arguments to delete one TaskNoteMention.
     * @example
     * // Delete one TaskNoteMention
     * const TaskNoteMention = await prisma.taskNoteMention.delete({
     *   where: {
     *     // ... filter to delete one TaskNoteMention
     *   }
     * })
     * 
     */
    delete<T extends TaskNoteMentionDeleteArgs>(args: SelectSubset<T, TaskNoteMentionDeleteArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskNoteMention.
     * @param {TaskNoteMentionUpdateArgs} args - Arguments to update one TaskNoteMention.
     * @example
     * // Update one TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskNoteMentionUpdateArgs>(args: SelectSubset<T, TaskNoteMentionUpdateArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskNoteMentions.
     * @param {TaskNoteMentionDeleteManyArgs} args - Arguments to filter TaskNoteMentions to delete.
     * @example
     * // Delete a few TaskNoteMentions
     * const { count } = await prisma.taskNoteMention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskNoteMentionDeleteManyArgs>(args?: SelectSubset<T, TaskNoteMentionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNoteMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskNoteMentions
     * const taskNoteMention = await prisma.taskNoteMention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskNoteMentionUpdateManyArgs>(args: SelectSubset<T, TaskNoteMentionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNoteMentions and returns the data updated in the database.
     * @param {TaskNoteMentionUpdateManyAndReturnArgs} args - Arguments to update many TaskNoteMentions.
     * @example
     * // Update many TaskNoteMentions
     * const taskNoteMention = await prisma.taskNoteMention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskNoteMentions and only return the `id`
     * const taskNoteMentionWithIdOnly = await prisma.taskNoteMention.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskNoteMentionUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskNoteMentionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskNoteMention.
     * @param {TaskNoteMentionUpsertArgs} args - Arguments to update or create a TaskNoteMention.
     * @example
     * // Update or create a TaskNoteMention
     * const taskNoteMention = await prisma.taskNoteMention.upsert({
     *   create: {
     *     // ... data to create a TaskNoteMention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskNoteMention we want to update
     *   }
     * })
     */
    upsert<T extends TaskNoteMentionUpsertArgs>(args: SelectSubset<T, TaskNoteMentionUpsertArgs<ExtArgs>>): Prisma__TaskNoteMentionClient<$Result.GetResult<Prisma.$TaskNoteMentionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskNoteMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionCountArgs} args - Arguments to filter TaskNoteMentions to count.
     * @example
     * // Count the number of TaskNoteMentions
     * const count = await prisma.taskNoteMention.count({
     *   where: {
     *     // ... the filter for the TaskNoteMentions we want to count
     *   }
     * })
    **/
    count<T extends TaskNoteMentionCountArgs>(
      args?: Subset<T, TaskNoteMentionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskNoteMentionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskNoteMention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskNoteMentionAggregateArgs>(args: Subset<T, TaskNoteMentionAggregateArgs>): Prisma.PrismaPromise<GetTaskNoteMentionAggregateType<T>>

    /**
     * Group by TaskNoteMention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteMentionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskNoteMentionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskNoteMentionGroupByArgs['orderBy'] }
        : { orderBy?: TaskNoteMentionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskNoteMentionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskNoteMentionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskNoteMention model
   */
  readonly fields: TaskNoteMentionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskNoteMention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskNoteMentionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends TaskNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskNoteDefaultArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskNoteMention model
   */
  interface TaskNoteMentionFieldRefs {
    readonly id: FieldRef<"TaskNoteMention", 'String'>
    readonly noteId: FieldRef<"TaskNoteMention", 'String'>
    readonly userId: FieldRef<"TaskNoteMention", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskNoteMention findUnique
   */
  export type TaskNoteMentionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter, which TaskNoteMention to fetch.
     */
    where: TaskNoteMentionWhereUniqueInput
  }

  /**
   * TaskNoteMention findUniqueOrThrow
   */
  export type TaskNoteMentionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter, which TaskNoteMention to fetch.
     */
    where: TaskNoteMentionWhereUniqueInput
  }

  /**
   * TaskNoteMention findFirst
   */
  export type TaskNoteMentionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter, which TaskNoteMention to fetch.
     */
    where?: TaskNoteMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNoteMentions to fetch.
     */
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNoteMentions.
     */
    cursor?: TaskNoteMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNoteMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNoteMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNoteMentions.
     */
    distinct?: TaskNoteMentionScalarFieldEnum | TaskNoteMentionScalarFieldEnum[]
  }

  /**
   * TaskNoteMention findFirstOrThrow
   */
  export type TaskNoteMentionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter, which TaskNoteMention to fetch.
     */
    where?: TaskNoteMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNoteMentions to fetch.
     */
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNoteMentions.
     */
    cursor?: TaskNoteMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNoteMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNoteMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNoteMentions.
     */
    distinct?: TaskNoteMentionScalarFieldEnum | TaskNoteMentionScalarFieldEnum[]
  }

  /**
   * TaskNoteMention findMany
   */
  export type TaskNoteMentionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter, which TaskNoteMentions to fetch.
     */
    where?: TaskNoteMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNoteMentions to fetch.
     */
    orderBy?: TaskNoteMentionOrderByWithRelationInput | TaskNoteMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskNoteMentions.
     */
    cursor?: TaskNoteMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNoteMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNoteMentions.
     */
    skip?: number
    distinct?: TaskNoteMentionScalarFieldEnum | TaskNoteMentionScalarFieldEnum[]
  }

  /**
   * TaskNoteMention create
   */
  export type TaskNoteMentionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskNoteMention.
     */
    data: XOR<TaskNoteMentionCreateInput, TaskNoteMentionUncheckedCreateInput>
  }

  /**
   * TaskNoteMention createMany
   */
  export type TaskNoteMentionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskNoteMentions.
     */
    data: TaskNoteMentionCreateManyInput | TaskNoteMentionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskNoteMention createManyAndReturn
   */
  export type TaskNoteMentionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * The data used to create many TaskNoteMentions.
     */
    data: TaskNoteMentionCreateManyInput | TaskNoteMentionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNoteMention update
   */
  export type TaskNoteMentionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskNoteMention.
     */
    data: XOR<TaskNoteMentionUpdateInput, TaskNoteMentionUncheckedUpdateInput>
    /**
     * Choose, which TaskNoteMention to update.
     */
    where: TaskNoteMentionWhereUniqueInput
  }

  /**
   * TaskNoteMention updateMany
   */
  export type TaskNoteMentionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskNoteMentions.
     */
    data: XOR<TaskNoteMentionUpdateManyMutationInput, TaskNoteMentionUncheckedUpdateManyInput>
    /**
     * Filter which TaskNoteMentions to update
     */
    where?: TaskNoteMentionWhereInput
    /**
     * Limit how many TaskNoteMentions to update.
     */
    limit?: number
  }

  /**
   * TaskNoteMention updateManyAndReturn
   */
  export type TaskNoteMentionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * The data used to update TaskNoteMentions.
     */
    data: XOR<TaskNoteMentionUpdateManyMutationInput, TaskNoteMentionUncheckedUpdateManyInput>
    /**
     * Filter which TaskNoteMentions to update
     */
    where?: TaskNoteMentionWhereInput
    /**
     * Limit how many TaskNoteMentions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNoteMention upsert
   */
  export type TaskNoteMentionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskNoteMention to update in case it exists.
     */
    where: TaskNoteMentionWhereUniqueInput
    /**
     * In case the TaskNoteMention found by the `where` argument doesn't exist, create a new TaskNoteMention with this data.
     */
    create: XOR<TaskNoteMentionCreateInput, TaskNoteMentionUncheckedCreateInput>
    /**
     * In case the TaskNoteMention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskNoteMentionUpdateInput, TaskNoteMentionUncheckedUpdateInput>
  }

  /**
   * TaskNoteMention delete
   */
  export type TaskNoteMentionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
    /**
     * Filter which TaskNoteMention to delete.
     */
    where: TaskNoteMentionWhereUniqueInput
  }

  /**
   * TaskNoteMention deleteMany
   */
  export type TaskNoteMentionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNoteMentions to delete
     */
    where?: TaskNoteMentionWhereInput
    /**
     * Limit how many TaskNoteMentions to delete.
     */
    limit?: number
  }

  /**
   * TaskNoteMention without action
   */
  export type TaskNoteMentionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNoteMention
     */
    select?: TaskNoteMentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNoteMention
     */
    omit?: TaskNoteMentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteMentionInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    description: string | null
    type: $Enums.CalendarItemType | null
    startAt: Date | null
    endAt: Date | null
    googleEventId: string | null
    googleCalendarId: string | null
    syncedAt: Date | null
    location: string | null
    createdAt: Date | null
    relatedTaskId: string | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    description: string | null
    type: $Enums.CalendarItemType | null
    startAt: Date | null
    endAt: Date | null
    googleEventId: string | null
    googleCalendarId: string | null
    syncedAt: Date | null
    location: string | null
    createdAt: Date | null
    relatedTaskId: string | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    teamId: number
    title: number
    description: number
    type: number
    startAt: number
    endAt: number
    googleEventId: number
    googleCalendarId: number
    syncedAt: number
    location: number
    createdAt: number
    relatedTaskId: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    type?: true
    startAt?: true
    endAt?: true
    googleEventId?: true
    googleCalendarId?: true
    syncedAt?: true
    location?: true
    createdAt?: true
    relatedTaskId?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    type?: true
    startAt?: true
    endAt?: true
    googleEventId?: true
    googleCalendarId?: true
    syncedAt?: true
    location?: true
    createdAt?: true
    relatedTaskId?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    description?: true
    type?: true
    startAt?: true
    endAt?: true
    googleEventId?: true
    googleCalendarId?: true
    syncedAt?: true
    location?: true
    createdAt?: true
    relatedTaskId?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    teamId: string
    title: string
    description: string | null
    type: $Enums.CalendarItemType
    startAt: Date
    endAt: Date
    googleEventId: string | null
    googleCalendarId: string | null
    syncedAt: Date | null
    location: string | null
    createdAt: Date
    relatedTaskId: string | null
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startAt?: boolean
    endAt?: boolean
    googleEventId?: boolean
    googleCalendarId?: boolean
    syncedAt?: boolean
    location?: boolean
    createdAt?: boolean
    relatedTaskId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startAt?: boolean
    endAt?: boolean
    googleEventId?: boolean
    googleCalendarId?: boolean
    syncedAt?: boolean
    location?: boolean
    createdAt?: boolean
    relatedTaskId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startAt?: boolean
    endAt?: boolean
    googleEventId?: boolean
    googleCalendarId?: boolean
    syncedAt?: boolean
    location?: boolean
    createdAt?: boolean
    relatedTaskId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    teamId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startAt?: boolean
    endAt?: boolean
    googleEventId?: boolean
    googleCalendarId?: boolean
    syncedAt?: boolean
    location?: boolean
    createdAt?: boolean
    relatedTaskId?: boolean
  }

  export type CalendarEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "title" | "description" | "type" | "startAt" | "endAt" | "googleEventId" | "googleCalendarId" | "syncedAt" | "location" | "createdAt" | "relatedTaskId", ExtArgs["result"]["calendarEvent"]>
  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }
  export type CalendarEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    task?: boolean | CalendarEvent$taskArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      title: string
      description: string | null
      type: $Enums.CalendarItemType
      startAt: Date
      endAt: Date
      googleEventId: string | null
      googleCalendarId: string | null
      syncedAt: Date | null
      location: string | null
      createdAt: Date
      relatedTaskId: string | null
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents and returns the data updated in the database.
     * @param {CalendarEventUpdateManyAndReturnArgs} args - Arguments to update many CalendarEvents.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends CalendarEvent$taskArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly teamId: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
    readonly type: FieldRef<"CalendarEvent", 'CalendarItemType'>
    readonly startAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly googleEventId: FieldRef<"CalendarEvent", 'String'>
    readonly googleCalendarId: FieldRef<"CalendarEvent", 'String'>
    readonly syncedAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly relatedTaskId: FieldRef<"CalendarEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to update.
     */
    limit?: number
  }

  /**
   * CalendarEvent updateManyAndReturn
   */
  export type CalendarEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to delete.
     */
    limit?: number
  }

  /**
   * CalendarEvent.task
   */
  export type CalendarEvent$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    handle: 'handle',
    name: 'name',
    createdAt: 'createdAt',
    googleEmail: 'googleEmail',
    googleRefreshToken: 'googleRefreshToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const IdentityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerId: 'providerId'
  };

  export type IdentityScalarFieldEnum = (typeof IdentityScalarFieldEnum)[keyof typeof IdentityScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrgMembershipScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    userId: 'userId',
    role: 'role'
  };

  export type OrgMembershipScalarFieldEnum = (typeof OrgMembershipScalarFieldEnum)[keyof typeof OrgMembershipScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    info: 'info'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamLinkScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    label: 'label',
    url: 'url',
    ordinal: 'ordinal'
  };

  export type TeamLinkScalarFieldEnum = (typeof TeamLinkScalarFieldEnum)[keyof typeof TeamLinkScalarFieldEnum]


  export const TeamMembershipScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role'
  };

  export type TeamMembershipScalarFieldEnum = (typeof TeamMembershipScalarFieldEnum)[keyof typeof TeamMembershipScalarFieldEnum]


  export const TeamJoinCodeScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    code: 'code',
    expiresAt: 'expiresAt',
    maxUses: 'maxUses',
    uses: 'uses'
  };

  export type TeamJoinCodeScalarFieldEnum = (typeof TeamJoinCodeScalarFieldEnum)[keyof typeof TeamJoinCodeScalarFieldEnum]


  export const OrgJoinCodeScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    code: 'code',
    expiresAt: 'expiresAt',
    maxUses: 'maxUses',
    uses: 'uses',
    createdAt: 'createdAt'
  };

  export type OrgJoinCodeScalarFieldEnum = (typeof OrgJoinCodeScalarFieldEnum)[keyof typeof OrgJoinCodeScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    title: 'title',
    description: 'description',
    dueDate: 'dueDate',
    status: 'status'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    goalId: 'goalId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskAssignmentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId'
  };

  export type TaskAssignmentScalarFieldEnum = (typeof TaskAssignmentScalarFieldEnum)[keyof typeof TaskAssignmentScalarFieldEnum]


  export const TaskNoteScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type TaskNoteScalarFieldEnum = (typeof TaskNoteScalarFieldEnum)[keyof typeof TaskNoteScalarFieldEnum]


  export const TaskNoteMentionScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    userId: 'userId'
  };

  export type TaskNoteMentionScalarFieldEnum = (typeof TaskNoteMentionScalarFieldEnum)[keyof typeof TaskNoteMentionScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    title: 'title',
    description: 'description',
    type: 'type',
    startAt: 'startAt',
    endAt: 'endAt',
    googleEventId: 'googleEventId',
    googleCalendarId: 'googleCalendarId',
    syncedAt: 'syncedAt',
    location: 'location',
    createdAt: 'createdAt',
    relatedTaskId: 'relatedTaskId'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'OrgRole'
   */
  export type EnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole'>
    


  /**
   * Reference to a field of type 'OrgRole[]'
   */
  export type ListEnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'CalendarItemType'
   */
  export type EnumCalendarItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarItemType'>
    


  /**
   * Reference to a field of type 'CalendarItemType[]'
   */
  export type ListEnumCalendarItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarItemType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    handle?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    googleEmail?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    identities?: IdentityListRelationFilter
    memberships?: OrgMembershipListRelationFilter
    teamMemberships?: TeamMembershipListRelationFilter
    notes?: TaskNoteListRelationFilter
    TaskAssignment?: TaskAssignmentListRelationFilter
    TaskNoteMention?: TaskNoteMentionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    handle?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    googleEmail?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    identities?: IdentityOrderByRelationAggregateInput
    memberships?: OrgMembershipOrderByRelationAggregateInput
    teamMemberships?: TeamMembershipOrderByRelationAggregateInput
    notes?: TaskNoteOrderByRelationAggregateInput
    TaskAssignment?: TaskAssignmentOrderByRelationAggregateInput
    TaskNoteMention?: TaskNoteMentionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    handle?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    googleEmail?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    identities?: IdentityListRelationFilter
    memberships?: OrgMembershipListRelationFilter
    teamMemberships?: TeamMembershipListRelationFilter
    notes?: TaskNoteListRelationFilter
    TaskAssignment?: TaskAssignmentListRelationFilter
    TaskNoteMention?: TaskNoteMentionListRelationFilter
  }, "id" | "email" | "handle">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    handle?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    googleEmail?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    handle?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    googleEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleRefreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type IdentityWhereInput = {
    AND?: IdentityWhereInput | IdentityWhereInput[]
    OR?: IdentityWhereInput[]
    NOT?: IdentityWhereInput | IdentityWhereInput[]
    id?: StringFilter<"Identity"> | string
    userId?: StringFilter<"Identity"> | string
    provider?: StringFilter<"Identity"> | string
    providerId?: StringFilter<"Identity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IdentityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IdentityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerId?: IdentityProviderProviderIdCompoundUniqueInput
    AND?: IdentityWhereInput | IdentityWhereInput[]
    OR?: IdentityWhereInput[]
    NOT?: IdentityWhereInput | IdentityWhereInput[]
    userId?: StringFilter<"Identity"> | string
    provider?: StringFilter<"Identity"> | string
    providerId?: StringFilter<"Identity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerId">

  export type IdentityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    _count?: IdentityCountOrderByAggregateInput
    _max?: IdentityMaxOrderByAggregateInput
    _min?: IdentityMinOrderByAggregateInput
  }

  export type IdentityScalarWhereWithAggregatesInput = {
    AND?: IdentityScalarWhereWithAggregatesInput | IdentityScalarWhereWithAggregatesInput[]
    OR?: IdentityScalarWhereWithAggregatesInput[]
    NOT?: IdentityScalarWhereWithAggregatesInput | IdentityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Identity"> | string
    userId?: StringWithAggregatesFilter<"Identity"> | string
    provider?: StringWithAggregatesFilter<"Identity"> | string
    providerId?: StringWithAggregatesFilter<"Identity"> | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    createdBy?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    memberships?: OrgMembershipListRelationFilter
    teams?: TeamListRelationFilter
    orgJoinCodes?: OrgJoinCodeListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    memberships?: OrgMembershipOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    orgJoinCodes?: OrgJoinCodeOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    createdBy?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    memberships?: OrgMembershipListRelationFilter
    teams?: TeamListRelationFilter
    orgJoinCodes?: OrgJoinCodeListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    createdBy?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrgMembershipWhereInput = {
    AND?: OrgMembershipWhereInput | OrgMembershipWhereInput[]
    OR?: OrgMembershipWhereInput[]
    NOT?: OrgMembershipWhereInput | OrgMembershipWhereInput[]
    id?: StringFilter<"OrgMembership"> | string
    orgId?: StringFilter<"OrgMembership"> | string
    userId?: StringFilter<"OrgMembership"> | string
    role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrgMembershipOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    org?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrgMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId_userId?: OrgMembershipOrgIdUserIdCompoundUniqueInput
    AND?: OrgMembershipWhereInput | OrgMembershipWhereInput[]
    OR?: OrgMembershipWhereInput[]
    NOT?: OrgMembershipWhereInput | OrgMembershipWhereInput[]
    orgId?: StringFilter<"OrgMembership"> | string
    userId?: StringFilter<"OrgMembership"> | string
    role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orgId_userId">

  export type OrgMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: OrgMembershipCountOrderByAggregateInput
    _max?: OrgMembershipMaxOrderByAggregateInput
    _min?: OrgMembershipMinOrderByAggregateInput
  }

  export type OrgMembershipScalarWhereWithAggregatesInput = {
    AND?: OrgMembershipScalarWhereWithAggregatesInput | OrgMembershipScalarWhereWithAggregatesInput[]
    OR?: OrgMembershipScalarWhereWithAggregatesInput[]
    NOT?: OrgMembershipScalarWhereWithAggregatesInput | OrgMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrgMembership"> | string
    orgId?: StringWithAggregatesFilter<"OrgMembership"> | string
    userId?: StringWithAggregatesFilter<"OrgMembership"> | string
    role?: EnumOrgRoleWithAggregatesFilter<"OrgMembership"> | $Enums.OrgRole
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    orgId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    info?: StringNullableFilter<"Team"> | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    memberships?: TeamMembershipListRelationFilter
    goals?: GoalListRelationFilter
    tasks?: TaskListRelationFilter
    events?: CalendarEventListRelationFilter
    joinCodes?: TeamJoinCodeListRelationFilter
    links?: TeamLinkListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    info?: SortOrderInput | SortOrder
    org?: OrganizationOrderByWithRelationInput
    memberships?: TeamMembershipOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    events?: CalendarEventOrderByRelationAggregateInput
    joinCodes?: TeamJoinCodeOrderByRelationAggregateInput
    links?: TeamLinkOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    orgId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    info?: StringNullableFilter<"Team"> | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    memberships?: TeamMembershipListRelationFilter
    goals?: GoalListRelationFilter
    tasks?: TaskListRelationFilter
    events?: CalendarEventListRelationFilter
    joinCodes?: TeamJoinCodeListRelationFilter
    links?: TeamLinkListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    info?: SortOrderInput | SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    orgId?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    createdBy?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    info?: StringNullableWithAggregatesFilter<"Team"> | string | null
  }

  export type TeamLinkWhereInput = {
    AND?: TeamLinkWhereInput | TeamLinkWhereInput[]
    OR?: TeamLinkWhereInput[]
    NOT?: TeamLinkWhereInput | TeamLinkWhereInput[]
    id?: StringFilter<"TeamLink"> | string
    teamId?: StringFilter<"TeamLink"> | string
    label?: StringFilter<"TeamLink"> | string
    url?: StringFilter<"TeamLink"> | string
    ordinal?: IntFilter<"TeamLink"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TeamLinkOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    label?: SortOrder
    url?: SortOrder
    ordinal?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type TeamLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamLinkWhereInput | TeamLinkWhereInput[]
    OR?: TeamLinkWhereInput[]
    NOT?: TeamLinkWhereInput | TeamLinkWhereInput[]
    teamId?: StringFilter<"TeamLink"> | string
    label?: StringFilter<"TeamLink"> | string
    url?: StringFilter<"TeamLink"> | string
    ordinal?: IntFilter<"TeamLink"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id">

  export type TeamLinkOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    label?: SortOrder
    url?: SortOrder
    ordinal?: SortOrder
    _count?: TeamLinkCountOrderByAggregateInput
    _avg?: TeamLinkAvgOrderByAggregateInput
    _max?: TeamLinkMaxOrderByAggregateInput
    _min?: TeamLinkMinOrderByAggregateInput
    _sum?: TeamLinkSumOrderByAggregateInput
  }

  export type TeamLinkScalarWhereWithAggregatesInput = {
    AND?: TeamLinkScalarWhereWithAggregatesInput | TeamLinkScalarWhereWithAggregatesInput[]
    OR?: TeamLinkScalarWhereWithAggregatesInput[]
    NOT?: TeamLinkScalarWhereWithAggregatesInput | TeamLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamLink"> | string
    teamId?: StringWithAggregatesFilter<"TeamLink"> | string
    label?: StringWithAggregatesFilter<"TeamLink"> | string
    url?: StringWithAggregatesFilter<"TeamLink"> | string
    ordinal?: IntWithAggregatesFilter<"TeamLink"> | number
  }

  export type TeamMembershipWhereInput = {
    AND?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    OR?: TeamMembershipWhereInput[]
    NOT?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    id?: StringFilter<"TeamMembership"> | string
    teamId?: StringFilter<"TeamMembership"> | string
    userId?: StringFilter<"TeamMembership"> | string
    role?: EnumTeamRoleFilter<"TeamMembership"> | $Enums.TeamRole
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMembershipOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMembershipTeamIdUserIdCompoundUniqueInput
    AND?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    OR?: TeamMembershipWhereInput[]
    NOT?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    teamId?: StringFilter<"TeamMembership"> | string
    userId?: StringFilter<"TeamMembership"> | string
    role?: EnumTeamRoleFilter<"TeamMembership"> | $Enums.TeamRole
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: TeamMembershipCountOrderByAggregateInput
    _max?: TeamMembershipMaxOrderByAggregateInput
    _min?: TeamMembershipMinOrderByAggregateInput
  }

  export type TeamMembershipScalarWhereWithAggregatesInput = {
    AND?: TeamMembershipScalarWhereWithAggregatesInput | TeamMembershipScalarWhereWithAggregatesInput[]
    OR?: TeamMembershipScalarWhereWithAggregatesInput[]
    NOT?: TeamMembershipScalarWhereWithAggregatesInput | TeamMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMembership"> | string
    teamId?: StringWithAggregatesFilter<"TeamMembership"> | string
    userId?: StringWithAggregatesFilter<"TeamMembership"> | string
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMembership"> | $Enums.TeamRole
  }

  export type TeamJoinCodeWhereInput = {
    AND?: TeamJoinCodeWhereInput | TeamJoinCodeWhereInput[]
    OR?: TeamJoinCodeWhereInput[]
    NOT?: TeamJoinCodeWhereInput | TeamJoinCodeWhereInput[]
    id?: StringFilter<"TeamJoinCode"> | string
    teamId?: StringFilter<"TeamJoinCode"> | string
    code?: StringFilter<"TeamJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"TeamJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"TeamJoinCode"> | number | null
    uses?: IntFilter<"TeamJoinCode"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TeamJoinCodeOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type TeamJoinCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TeamJoinCodeWhereInput | TeamJoinCodeWhereInput[]
    OR?: TeamJoinCodeWhereInput[]
    NOT?: TeamJoinCodeWhereInput | TeamJoinCodeWhereInput[]
    teamId?: StringFilter<"TeamJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"TeamJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"TeamJoinCode"> | number | null
    uses?: IntFilter<"TeamJoinCode"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "code">

  export type TeamJoinCodeOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    _count?: TeamJoinCodeCountOrderByAggregateInput
    _avg?: TeamJoinCodeAvgOrderByAggregateInput
    _max?: TeamJoinCodeMaxOrderByAggregateInput
    _min?: TeamJoinCodeMinOrderByAggregateInput
    _sum?: TeamJoinCodeSumOrderByAggregateInput
  }

  export type TeamJoinCodeScalarWhereWithAggregatesInput = {
    AND?: TeamJoinCodeScalarWhereWithAggregatesInput | TeamJoinCodeScalarWhereWithAggregatesInput[]
    OR?: TeamJoinCodeScalarWhereWithAggregatesInput[]
    NOT?: TeamJoinCodeScalarWhereWithAggregatesInput | TeamJoinCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamJoinCode"> | string
    teamId?: StringWithAggregatesFilter<"TeamJoinCode"> | string
    code?: StringWithAggregatesFilter<"TeamJoinCode"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TeamJoinCode"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"TeamJoinCode"> | number | null
    uses?: IntWithAggregatesFilter<"TeamJoinCode"> | number
  }

  export type OrgJoinCodeWhereInput = {
    AND?: OrgJoinCodeWhereInput | OrgJoinCodeWhereInput[]
    OR?: OrgJoinCodeWhereInput[]
    NOT?: OrgJoinCodeWhereInput | OrgJoinCodeWhereInput[]
    id?: StringFilter<"OrgJoinCode"> | string
    orgId?: StringFilter<"OrgJoinCode"> | string
    code?: StringFilter<"OrgJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"OrgJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"OrgJoinCode"> | number | null
    uses?: IntFilter<"OrgJoinCode"> | number
    createdAt?: DateTimeFilter<"OrgJoinCode"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrgJoinCodeOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    createdAt?: SortOrder
    org?: OrganizationOrderByWithRelationInput
  }

  export type OrgJoinCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OrgJoinCodeWhereInput | OrgJoinCodeWhereInput[]
    OR?: OrgJoinCodeWhereInput[]
    NOT?: OrgJoinCodeWhereInput | OrgJoinCodeWhereInput[]
    orgId?: StringFilter<"OrgJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"OrgJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"OrgJoinCode"> | number | null
    uses?: IntFilter<"OrgJoinCode"> | number
    createdAt?: DateTimeFilter<"OrgJoinCode"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "code">

  export type OrgJoinCodeOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    createdAt?: SortOrder
    _count?: OrgJoinCodeCountOrderByAggregateInput
    _avg?: OrgJoinCodeAvgOrderByAggregateInput
    _max?: OrgJoinCodeMaxOrderByAggregateInput
    _min?: OrgJoinCodeMinOrderByAggregateInput
    _sum?: OrgJoinCodeSumOrderByAggregateInput
  }

  export type OrgJoinCodeScalarWhereWithAggregatesInput = {
    AND?: OrgJoinCodeScalarWhereWithAggregatesInput | OrgJoinCodeScalarWhereWithAggregatesInput[]
    OR?: OrgJoinCodeScalarWhereWithAggregatesInput[]
    NOT?: OrgJoinCodeScalarWhereWithAggregatesInput | OrgJoinCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrgJoinCode"> | string
    orgId?: StringWithAggregatesFilter<"OrgJoinCode"> | string
    code?: StringWithAggregatesFilter<"OrgJoinCode"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OrgJoinCode"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"OrgJoinCode"> | number | null
    uses?: IntWithAggregatesFilter<"OrgJoinCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrgJoinCode"> | Date | string
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    teamId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    team?: TeamOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    teamId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    teamId?: StringWithAggregatesFilter<"Goal"> | string
    title?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    status?: StringWithAggregatesFilter<"Goal"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    teamId?: StringFilter<"Task"> | string
    goalId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdBy?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    assignees?: TaskAssignmentListRelationFilter
    notes?: TaskNoteListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    goalId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    goal?: GoalOrderByWithRelationInput
    assignees?: TaskAssignmentOrderByRelationAggregateInput
    notes?: TaskNoteOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    teamId?: StringFilter<"Task"> | string
    goalId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdBy?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    assignees?: TaskAssignmentListRelationFilter
    notes?: TaskNoteListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    goalId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    teamId?: StringWithAggregatesFilter<"Task"> | string
    goalId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityWithAggregatesFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskAssignmentWhereInput = {
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    taskId?: StringFilter<"TaskAssignment"> | string
    userId?: StringFilter<"TaskAssignment"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId_userId?: TaskAssignmentTaskIdUserIdCompoundUniqueInput
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    taskId?: StringFilter<"TaskAssignment"> | string
    userId?: StringFilter<"TaskAssignment"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "taskId_userId">

  export type TaskAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    _count?: TaskAssignmentCountOrderByAggregateInput
    _max?: TaskAssignmentMaxOrderByAggregateInput
    _min?: TaskAssignmentMinOrderByAggregateInput
  }

  export type TaskAssignmentScalarWhereWithAggregatesInput = {
    AND?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    OR?: TaskAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAssignment"> | string
    taskId?: StringWithAggregatesFilter<"TaskAssignment"> | string
    userId?: StringWithAggregatesFilter<"TaskAssignment"> | string
  }

  export type TaskNoteWhereInput = {
    AND?: TaskNoteWhereInput | TaskNoteWhereInput[]
    OR?: TaskNoteWhereInput[]
    NOT?: TaskNoteWhereInput | TaskNoteWhereInput[]
    id?: StringFilter<"TaskNote"> | string
    taskId?: StringFilter<"TaskNote"> | string
    authorId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    mentions?: TaskNoteMentionListRelationFilter
  }

  export type TaskNoteOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    mentions?: TaskNoteMentionOrderByRelationAggregateInput
  }

  export type TaskNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskNoteWhereInput | TaskNoteWhereInput[]
    OR?: TaskNoteWhereInput[]
    NOT?: TaskNoteWhereInput | TaskNoteWhereInput[]
    taskId?: StringFilter<"TaskNote"> | string
    authorId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    mentions?: TaskNoteMentionListRelationFilter
  }, "id">

  export type TaskNoteOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: TaskNoteCountOrderByAggregateInput
    _max?: TaskNoteMaxOrderByAggregateInput
    _min?: TaskNoteMinOrderByAggregateInput
  }

  export type TaskNoteScalarWhereWithAggregatesInput = {
    AND?: TaskNoteScalarWhereWithAggregatesInput | TaskNoteScalarWhereWithAggregatesInput[]
    OR?: TaskNoteScalarWhereWithAggregatesInput[]
    NOT?: TaskNoteScalarWhereWithAggregatesInput | TaskNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskNote"> | string
    taskId?: StringWithAggregatesFilter<"TaskNote"> | string
    authorId?: StringWithAggregatesFilter<"TaskNote"> | string
    content?: StringWithAggregatesFilter<"TaskNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskNote"> | Date | string
  }

  export type TaskNoteMentionWhereInput = {
    AND?: TaskNoteMentionWhereInput | TaskNoteMentionWhereInput[]
    OR?: TaskNoteMentionWhereInput[]
    NOT?: TaskNoteMentionWhereInput | TaskNoteMentionWhereInput[]
    id?: StringFilter<"TaskNoteMention"> | string
    noteId?: StringFilter<"TaskNoteMention"> | string
    userId?: StringFilter<"TaskNoteMention"> | string
    note?: XOR<TaskNoteScalarRelationFilter, TaskNoteWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskNoteMentionOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    userId?: SortOrder
    note?: TaskNoteOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskNoteMentionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    noteId_userId?: TaskNoteMentionNoteIdUserIdCompoundUniqueInput
    AND?: TaskNoteMentionWhereInput | TaskNoteMentionWhereInput[]
    OR?: TaskNoteMentionWhereInput[]
    NOT?: TaskNoteMentionWhereInput | TaskNoteMentionWhereInput[]
    noteId?: StringFilter<"TaskNoteMention"> | string
    userId?: StringFilter<"TaskNoteMention"> | string
    note?: XOR<TaskNoteScalarRelationFilter, TaskNoteWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "noteId_userId">

  export type TaskNoteMentionOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    userId?: SortOrder
    _count?: TaskNoteMentionCountOrderByAggregateInput
    _max?: TaskNoteMentionMaxOrderByAggregateInput
    _min?: TaskNoteMentionMinOrderByAggregateInput
  }

  export type TaskNoteMentionScalarWhereWithAggregatesInput = {
    AND?: TaskNoteMentionScalarWhereWithAggregatesInput | TaskNoteMentionScalarWhereWithAggregatesInput[]
    OR?: TaskNoteMentionScalarWhereWithAggregatesInput[]
    NOT?: TaskNoteMentionScalarWhereWithAggregatesInput | TaskNoteMentionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskNoteMention"> | string
    noteId?: StringWithAggregatesFilter<"TaskNoteMention"> | string
    userId?: StringWithAggregatesFilter<"TaskNoteMention"> | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    teamId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: EnumCalendarItemTypeFilter<"CalendarEvent"> | $Enums.CalendarItemType
    startAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    endAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    googleEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    googleCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncedAt?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    relatedTaskId?: StringNullableFilter<"CalendarEvent"> | string | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    googleEventId?: SortOrderInput | SortOrder
    googleCalendarId?: SortOrderInput | SortOrder
    syncedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedTaskId?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    googleEventId?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    teamId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: EnumCalendarItemTypeFilter<"CalendarEvent"> | $Enums.CalendarItemType
    startAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    endAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    googleCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncedAt?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    relatedTaskId?: StringNullableFilter<"CalendarEvent"> | string | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id" | "googleEventId">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    googleEventId?: SortOrderInput | SortOrder
    googleCalendarId?: SortOrderInput | SortOrder
    syncedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedTaskId?: SortOrderInput | SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    teamId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    type?: EnumCalendarItemTypeWithAggregatesFilter<"CalendarEvent"> | $Enums.CalendarItemType
    startAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    googleEventId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    googleCalendarId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    syncedAt?: DateTimeNullableWithAggregatesFilter<"CalendarEvent"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    relatedTaskId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdentityCreateInput = {
    id?: string
    provider: string
    providerId: string
    user: UserCreateNestedOneWithoutIdentitiesInput
  }

  export type IdentityUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerId: string
  }

  export type IdentityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIdentitiesNestedInput
  }

  export type IdentityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type IdentityCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerId: string
  }

  export type IdentityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type IdentityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipCreateNestedManyWithoutOrgInput
    teams?: TeamCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutOrgInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUpdateManyWithoutOrgNestedInput
    teams?: TeamUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMembershipCreateInput = {
    id?: string
    role: $Enums.OrgRole
    org: OrganizationCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type OrgMembershipUncheckedCreateInput = {
    id?: string
    orgId: string
    userId: string
    role: $Enums.OrgRole
  }

  export type OrgMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    org?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type OrgMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type OrgMembershipCreateManyInput = {
    id?: string
    orgId: string
    userId: string
    role: $Enums.OrgRole
  }

  export type OrgMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type OrgMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamLinkCreateInput = {
    id?: string
    label: string
    url: string
    ordinal?: number
    team: TeamCreateNestedOneWithoutLinksInput
  }

  export type TeamLinkUncheckedCreateInput = {
    id?: string
    teamId: string
    label: string
    url: string
    ordinal?: number
  }

  export type TeamLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutLinksNestedInput
  }

  export type TeamLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLinkCreateManyInput = {
    id?: string
    teamId: string
    label: string
    url: string
    ordinal?: number
  }

  export type TeamLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMembershipCreateInput = {
    id?: string
    role?: $Enums.TeamRole
    team: TeamCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMembershipUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
  }

  export type TeamMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    team?: TeamUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TeamMembershipCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
  }

  export type TeamMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TeamMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TeamJoinCodeCreateInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    team: TeamCreateNestedOneWithoutJoinCodesInput
  }

  export type TeamJoinCodeUncheckedCreateInput = {
    id?: string
    teamId: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
  }

  export type TeamJoinCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutJoinCodesNestedInput
  }

  export type TeamJoinCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type TeamJoinCodeCreateManyInput = {
    id?: string
    teamId: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
  }

  export type TeamJoinCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type TeamJoinCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type OrgJoinCodeCreateInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
    org: OrganizationCreateNestedOneWithoutOrgJoinCodesInput
  }

  export type OrgJoinCodeUncheckedCreateInput = {
    id?: string
    orgId: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
  }

  export type OrgJoinCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutOrgJoinCodesNestedInput
  }

  export type OrgJoinCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgJoinCodeCreateManyInput = {
    id?: string
    orgId: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
  }

  export type OrgJoinCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgJoinCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
    team: TeamCreateNestedOneWithoutGoalsInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutGoalsNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateManyInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTasksInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    assignees?: TaskAssignmentCreateNestedManyWithoutTaskInput
    notes?: TaskNoteCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    teamId: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    assignees?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    teamId: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateInput = {
    id?: string
    task: TaskCreateNestedOneWithoutAssigneesInput
    user: UserCreateNestedOneWithoutTaskAssignmentInput
  }

  export type TaskAssignmentUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
  }

  export type TaskAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput
    user?: UserUpdateOneRequiredWithoutTaskAssignmentNestedInput
  }

  export type TaskAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentCreateManyInput = {
    id?: string
    taskId: string
    userId: string
  }

  export type TaskAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    mentions?: TaskNoteMentionCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteUncheckedCreateInput = {
    id?: string
    taskId: string
    authorId: string
    content: string
    createdAt?: Date | string
    mentions?: TaskNoteMentionUncheckedCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    mentions?: TaskNoteMentionUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: TaskNoteMentionUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteCreateManyInput = {
    id?: string
    taskId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteMentionCreateInput = {
    id?: string
    note: TaskNoteCreateNestedOneWithoutMentionsInput
    user: UserCreateNestedOneWithoutTaskNoteMentionInput
  }

  export type TaskNoteMentionUncheckedCreateInput = {
    id?: string
    noteId: string
    userId: string
  }

  export type TaskNoteMentionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: TaskNoteUpdateOneRequiredWithoutMentionsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskNoteMentionNestedInput
  }

  export type TaskNoteMentionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteMentionCreateManyInput = {
    id?: string
    noteId: string
    userId: string
  }

  export type TaskNoteMentionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteMentionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutEventsInput
    task?: TaskCreateNestedOneWithoutCalendarEventsInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    relatedTaskId?: string | null
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutEventsNestedInput
    task?: TaskUpdateOneWithoutCalendarEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    relatedTaskId?: string | null
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IdentityListRelationFilter = {
    every?: IdentityWhereInput
    some?: IdentityWhereInput
    none?: IdentityWhereInput
  }

  export type OrgMembershipListRelationFilter = {
    every?: OrgMembershipWhereInput
    some?: OrgMembershipWhereInput
    none?: OrgMembershipWhereInput
  }

  export type TeamMembershipListRelationFilter = {
    every?: TeamMembershipWhereInput
    some?: TeamMembershipWhereInput
    none?: TeamMembershipWhereInput
  }

  export type TaskNoteListRelationFilter = {
    every?: TaskNoteWhereInput
    some?: TaskNoteWhereInput
    none?: TaskNoteWhereInput
  }

  export type TaskAssignmentListRelationFilter = {
    every?: TaskAssignmentWhereInput
    some?: TaskAssignmentWhereInput
    none?: TaskAssignmentWhereInput
  }

  export type TaskNoteMentionListRelationFilter = {
    every?: TaskNoteMentionWhereInput
    some?: TaskNoteMentionWhereInput
    none?: TaskNoteMentionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IdentityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrgMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskNoteMentionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    handle?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    googleEmail?: SortOrder
    googleRefreshToken?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    handle?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    googleEmail?: SortOrder
    googleRefreshToken?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    handle?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    googleEmail?: SortOrder
    googleRefreshToken?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type IdentityProviderProviderIdCompoundUniqueInput = {
    provider: string
    providerId: string
  }

  export type IdentityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type IdentityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type IdentityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type OrgJoinCodeListRelationFilter = {
    every?: OrgJoinCodeWhereInput
    some?: OrgJoinCodeWhereInput
    none?: OrgJoinCodeWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrgJoinCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrgMembershipOrgIdUserIdCompoundUniqueInput = {
    orgId: string
    userId: string
  }

  export type OrgMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type OrgMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type OrgMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type EnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type TeamJoinCodeListRelationFilter = {
    every?: TeamJoinCodeWhereInput
    some?: TeamJoinCodeWhereInput
    none?: TeamJoinCodeWhereInput
  }

  export type TeamLinkListRelationFilter = {
    every?: TeamLinkWhereInput
    some?: TeamLinkWhereInput
    none?: TeamLinkWhereInput
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamJoinCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    info?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    info?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    info?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamLinkCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    label?: SortOrder
    url?: SortOrder
    ordinal?: SortOrder
  }

  export type TeamLinkAvgOrderByAggregateInput = {
    ordinal?: SortOrder
  }

  export type TeamLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    label?: SortOrder
    url?: SortOrder
    ordinal?: SortOrder
  }

  export type TeamLinkMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    label?: SortOrder
    url?: SortOrder
    ordinal?: SortOrder
  }

  export type TeamLinkSumOrderByAggregateInput = {
    ordinal?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamMembershipTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type TeamMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type TeamMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TeamJoinCodeCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type TeamJoinCodeAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type TeamJoinCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type TeamJoinCodeMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type TeamJoinCodeSumOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrgJoinCodeCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    createdAt?: SortOrder
  }

  export type OrgJoinCodeAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type OrgJoinCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    createdAt?: SortOrder
  }

  export type OrgJoinCodeMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    createdAt?: SortOrder
  }

  export type OrgJoinCodeSumOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type GoalNullableScalarRelationFilter = {
    is?: GoalWhereInput | null
    isNot?: GoalWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAssignmentTaskIdUserIdCompoundUniqueInput = {
    taskId: string
    userId: string
  }

  export type TaskAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskNoteCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNoteMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNoteScalarRelationFilter = {
    is?: TaskNoteWhereInput
    isNot?: TaskNoteWhereInput
  }

  export type TaskNoteMentionNoteIdUserIdCompoundUniqueInput = {
    noteId: string
    userId: string
  }

  export type TaskNoteMentionCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    userId?: SortOrder
  }

  export type TaskNoteMentionMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    userId?: SortOrder
  }

  export type TaskNoteMentionMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    userId?: SortOrder
  }

  export type EnumCalendarItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarItemType | EnumCalendarItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarItemTypeFilter<$PrismaModel> | $Enums.CalendarItemType
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    googleEventId?: SortOrder
    googleCalendarId?: SortOrder
    syncedAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    relatedTaskId?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    googleEventId?: SortOrder
    googleCalendarId?: SortOrder
    syncedAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    relatedTaskId?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    googleEventId?: SortOrder
    googleCalendarId?: SortOrder
    syncedAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    relatedTaskId?: SortOrder
  }

  export type EnumCalendarItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarItemType | EnumCalendarItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarItemTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarItemTypeFilter<$PrismaModel>
  }

  export type IdentityCreateNestedManyWithoutUserInput = {
    create?: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput> | IdentityCreateWithoutUserInput[] | IdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutUserInput | IdentityCreateOrConnectWithoutUserInput[]
    createMany?: IdentityCreateManyUserInputEnvelope
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
  }

  export type OrgMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput> | OrgMembershipCreateWithoutUserInput[] | OrgMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutUserInput | OrgMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrgMembershipCreateManyUserInputEnvelope
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
  }

  export type TeamMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type TaskNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput> | TaskNoteCreateWithoutAuthorInput[] | TaskNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutAuthorInput | TaskNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: TaskNoteCreateManyAuthorInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskNoteMentionCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput> | TaskNoteMentionCreateWithoutUserInput[] | TaskNoteMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutUserInput | TaskNoteMentionCreateOrConnectWithoutUserInput[]
    createMany?: TaskNoteMentionCreateManyUserInputEnvelope
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
  }

  export type IdentityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput> | IdentityCreateWithoutUserInput[] | IdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutUserInput | IdentityCreateOrConnectWithoutUserInput[]
    createMany?: IdentityCreateManyUserInputEnvelope
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
  }

  export type OrgMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput> | OrgMembershipCreateWithoutUserInput[] | OrgMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutUserInput | OrgMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrgMembershipCreateManyUserInputEnvelope
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
  }

  export type TeamMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type TaskNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput> | TaskNoteCreateWithoutAuthorInput[] | TaskNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutAuthorInput | TaskNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: TaskNoteCreateManyAuthorInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput> | TaskNoteMentionCreateWithoutUserInput[] | TaskNoteMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutUserInput | TaskNoteMentionCreateOrConnectWithoutUserInput[]
    createMany?: TaskNoteMentionCreateManyUserInputEnvelope
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IdentityUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput> | IdentityCreateWithoutUserInput[] | IdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutUserInput | IdentityCreateOrConnectWithoutUserInput[]
    upsert?: IdentityUpsertWithWhereUniqueWithoutUserInput | IdentityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdentityCreateManyUserInputEnvelope
    set?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    disconnect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    delete?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    update?: IdentityUpdateWithWhereUniqueWithoutUserInput | IdentityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdentityUpdateManyWithWhereWithoutUserInput | IdentityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
  }

  export type OrgMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput> | OrgMembershipCreateWithoutUserInput[] | OrgMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutUserInput | OrgMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrgMembershipUpsertWithWhereUniqueWithoutUserInput | OrgMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrgMembershipCreateManyUserInputEnvelope
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    disconnect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    update?: OrgMembershipUpdateWithWhereUniqueWithoutUserInput | OrgMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrgMembershipUpdateManyWithWhereWithoutUserInput | OrgMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
  }

  export type TeamMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutUserInput | TeamMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutUserInput | TeamMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutUserInput | TeamMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type TaskNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput> | TaskNoteCreateWithoutAuthorInput[] | TaskNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutAuthorInput | TaskNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutAuthorInput | TaskNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TaskNoteCreateManyAuthorInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutAuthorInput | TaskNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutAuthorInput | TaskNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutUserInput | TaskAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutUserInput | TaskAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutUserInput | TaskAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskNoteMentionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput> | TaskNoteMentionCreateWithoutUserInput[] | TaskNoteMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutUserInput | TaskNoteMentionCreateOrConnectWithoutUserInput[]
    upsert?: TaskNoteMentionUpsertWithWhereUniqueWithoutUserInput | TaskNoteMentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNoteMentionCreateManyUserInputEnvelope
    set?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    disconnect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    delete?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    update?: TaskNoteMentionUpdateWithWhereUniqueWithoutUserInput | TaskNoteMentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNoteMentionUpdateManyWithWhereWithoutUserInput | TaskNoteMentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
  }

  export type IdentityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput> | IdentityCreateWithoutUserInput[] | IdentityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutUserInput | IdentityCreateOrConnectWithoutUserInput[]
    upsert?: IdentityUpsertWithWhereUniqueWithoutUserInput | IdentityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdentityCreateManyUserInputEnvelope
    set?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    disconnect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    delete?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    update?: IdentityUpdateWithWhereUniqueWithoutUserInput | IdentityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdentityUpdateManyWithWhereWithoutUserInput | IdentityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
  }

  export type OrgMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput> | OrgMembershipCreateWithoutUserInput[] | OrgMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutUserInput | OrgMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrgMembershipUpsertWithWhereUniqueWithoutUserInput | OrgMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrgMembershipCreateManyUserInputEnvelope
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    disconnect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    update?: OrgMembershipUpdateWithWhereUniqueWithoutUserInput | OrgMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrgMembershipUpdateManyWithWhereWithoutUserInput | OrgMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
  }

  export type TeamMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutUserInput | TeamMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutUserInput | TeamMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutUserInput | TeamMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput> | TaskNoteCreateWithoutAuthorInput[] | TaskNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutAuthorInput | TaskNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutAuthorInput | TaskNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TaskNoteCreateManyAuthorInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutAuthorInput | TaskNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutAuthorInput | TaskNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput> | TaskAssignmentCreateWithoutUserInput[] | TaskAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutUserInput | TaskAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutUserInput | TaskAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssignmentCreateManyUserInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutUserInput | TaskAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutUserInput | TaskAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput> | TaskNoteMentionCreateWithoutUserInput[] | TaskNoteMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutUserInput | TaskNoteMentionCreateOrConnectWithoutUserInput[]
    upsert?: TaskNoteMentionUpsertWithWhereUniqueWithoutUserInput | TaskNoteMentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNoteMentionCreateManyUserInputEnvelope
    set?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    disconnect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    delete?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    update?: TaskNoteMentionUpdateWithWhereUniqueWithoutUserInput | TaskNoteMentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNoteMentionUpdateManyWithWhereWithoutUserInput | TaskNoteMentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIdentitiesInput = {
    create?: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIdentitiesNestedInput = {
    create?: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentitiesInput
    upsert?: UserUpsertWithoutIdentitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIdentitiesInput, UserUpdateWithoutIdentitiesInput>, UserUncheckedUpdateWithoutIdentitiesInput>
  }

  export type OrgMembershipCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput> | OrgMembershipCreateWithoutOrgInput[] | OrgMembershipUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutOrgInput | OrgMembershipCreateOrConnectWithoutOrgInput[]
    createMany?: OrgMembershipCreateManyOrgInputEnvelope
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOrgInput = {
    create?: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput> | TeamCreateWithoutOrgInput[] | TeamUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrgInput | TeamCreateOrConnectWithoutOrgInput[]
    createMany?: TeamCreateManyOrgInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type OrgJoinCodeCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput> | OrgJoinCodeCreateWithoutOrgInput[] | OrgJoinCodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgJoinCodeCreateOrConnectWithoutOrgInput | OrgJoinCodeCreateOrConnectWithoutOrgInput[]
    createMany?: OrgJoinCodeCreateManyOrgInputEnvelope
    connect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
  }

  export type OrgMembershipUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput> | OrgMembershipCreateWithoutOrgInput[] | OrgMembershipUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutOrgInput | OrgMembershipCreateOrConnectWithoutOrgInput[]
    createMany?: OrgMembershipCreateManyOrgInputEnvelope
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput> | TeamCreateWithoutOrgInput[] | TeamUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrgInput | TeamCreateOrConnectWithoutOrgInput[]
    createMany?: TeamCreateManyOrgInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type OrgJoinCodeUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput> | OrgJoinCodeCreateWithoutOrgInput[] | OrgJoinCodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgJoinCodeCreateOrConnectWithoutOrgInput | OrgJoinCodeCreateOrConnectWithoutOrgInput[]
    createMany?: OrgJoinCodeCreateManyOrgInputEnvelope
    connect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
  }

  export type OrgMembershipUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput> | OrgMembershipCreateWithoutOrgInput[] | OrgMembershipUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutOrgInput | OrgMembershipCreateOrConnectWithoutOrgInput[]
    upsert?: OrgMembershipUpsertWithWhereUniqueWithoutOrgInput | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgMembershipCreateManyOrgInputEnvelope
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    disconnect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    update?: OrgMembershipUpdateWithWhereUniqueWithoutOrgInput | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgMembershipUpdateManyWithWhereWithoutOrgInput | OrgMembershipUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOrgNestedInput = {
    create?: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput> | TeamCreateWithoutOrgInput[] | TeamUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrgInput | TeamCreateOrConnectWithoutOrgInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrgInput | TeamUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: TeamCreateManyOrgInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrgInput | TeamUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrgInput | TeamUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type OrgJoinCodeUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput> | OrgJoinCodeCreateWithoutOrgInput[] | OrgJoinCodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgJoinCodeCreateOrConnectWithoutOrgInput | OrgJoinCodeCreateOrConnectWithoutOrgInput[]
    upsert?: OrgJoinCodeUpsertWithWhereUniqueWithoutOrgInput | OrgJoinCodeUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgJoinCodeCreateManyOrgInputEnvelope
    set?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    disconnect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    delete?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    connect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    update?: OrgJoinCodeUpdateWithWhereUniqueWithoutOrgInput | OrgJoinCodeUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgJoinCodeUpdateManyWithWhereWithoutOrgInput | OrgJoinCodeUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgJoinCodeScalarWhereInput | OrgJoinCodeScalarWhereInput[]
  }

  export type OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput> | OrgMembershipCreateWithoutOrgInput[] | OrgMembershipUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMembershipCreateOrConnectWithoutOrgInput | OrgMembershipCreateOrConnectWithoutOrgInput[]
    upsert?: OrgMembershipUpsertWithWhereUniqueWithoutOrgInput | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgMembershipCreateManyOrgInputEnvelope
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    disconnect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[]
    update?: OrgMembershipUpdateWithWhereUniqueWithoutOrgInput | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgMembershipUpdateManyWithWhereWithoutOrgInput | OrgMembershipUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput> | TeamCreateWithoutOrgInput[] | TeamUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrgInput | TeamCreateOrConnectWithoutOrgInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrgInput | TeamUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: TeamCreateManyOrgInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrgInput | TeamUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrgInput | TeamUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type OrgJoinCodeUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput> | OrgJoinCodeCreateWithoutOrgInput[] | OrgJoinCodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgJoinCodeCreateOrConnectWithoutOrgInput | OrgJoinCodeCreateOrConnectWithoutOrgInput[]
    upsert?: OrgJoinCodeUpsertWithWhereUniqueWithoutOrgInput | OrgJoinCodeUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgJoinCodeCreateManyOrgInputEnvelope
    set?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    disconnect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    delete?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    connect?: OrgJoinCodeWhereUniqueInput | OrgJoinCodeWhereUniqueInput[]
    update?: OrgJoinCodeUpdateWithWhereUniqueWithoutOrgInput | OrgJoinCodeUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgJoinCodeUpdateManyWithWhereWithoutOrgInput | OrgJoinCodeUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgJoinCodeScalarWhereInput | OrgJoinCodeScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrgRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrgRole
  }

  export type OrganizationUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput
    upsert?: OrganizationUpsertWithoutMembershipsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembershipsInput, OrganizationUpdateWithoutMembershipsInput>, OrganizationUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type OrganizationCreateNestedOneWithoutTeamsInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeamMembershipCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutTeamInput = {
    create?: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput> | GoalCreateWithoutTeamInput[] | GoalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutTeamInput | GoalCreateOrConnectWithoutTeamInput[]
    createMany?: GoalCreateManyTeamInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutTeamInput = {
    create?: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput> | CalendarEventCreateWithoutTeamInput[] | CalendarEventUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeamInput | CalendarEventCreateOrConnectWithoutTeamInput[]
    createMany?: CalendarEventCreateManyTeamInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type TeamJoinCodeCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput> | TeamJoinCodeCreateWithoutTeamInput[] | TeamJoinCodeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinCodeCreateOrConnectWithoutTeamInput | TeamJoinCodeCreateOrConnectWithoutTeamInput[]
    createMany?: TeamJoinCodeCreateManyTeamInputEnvelope
    connect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
  }

  export type TeamLinkCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput> | TeamLinkCreateWithoutTeamInput[] | TeamLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLinkCreateOrConnectWithoutTeamInput | TeamLinkCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLinkCreateManyTeamInputEnvelope
    connect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
  }

  export type TeamMembershipUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput> | GoalCreateWithoutTeamInput[] | GoalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutTeamInput | GoalCreateOrConnectWithoutTeamInput[]
    createMany?: GoalCreateManyTeamInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput> | CalendarEventCreateWithoutTeamInput[] | CalendarEventUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeamInput | CalendarEventCreateOrConnectWithoutTeamInput[]
    createMany?: CalendarEventCreateManyTeamInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput> | TeamJoinCodeCreateWithoutTeamInput[] | TeamJoinCodeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinCodeCreateOrConnectWithoutTeamInput | TeamJoinCodeCreateOrConnectWithoutTeamInput[]
    createMany?: TeamJoinCodeCreateManyTeamInputEnvelope
    connect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
  }

  export type TeamLinkUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput> | TeamLinkCreateWithoutTeamInput[] | TeamLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLinkCreateOrConnectWithoutTeamInput | TeamLinkCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLinkCreateManyTeamInputEnvelope
    connect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    upsert?: OrganizationUpsertWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeamsInput, OrganizationUpdateWithoutTeamsInput>, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamMembershipUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutTeamInput | TeamMembershipUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutTeamInput | TeamMembershipUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutTeamInput | TeamMembershipUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutTeamNestedInput = {
    create?: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput> | GoalCreateWithoutTeamInput[] | GoalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutTeamInput | GoalCreateOrConnectWithoutTeamInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutTeamInput | GoalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: GoalCreateManyTeamInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutTeamInput | GoalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutTeamInput | GoalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput> | CalendarEventCreateWithoutTeamInput[] | CalendarEventUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeamInput | CalendarEventCreateOrConnectWithoutTeamInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTeamInput | CalendarEventUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CalendarEventCreateManyTeamInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTeamInput | CalendarEventUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTeamInput | CalendarEventUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type TeamJoinCodeUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput> | TeamJoinCodeCreateWithoutTeamInput[] | TeamJoinCodeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinCodeCreateOrConnectWithoutTeamInput | TeamJoinCodeCreateOrConnectWithoutTeamInput[]
    upsert?: TeamJoinCodeUpsertWithWhereUniqueWithoutTeamInput | TeamJoinCodeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamJoinCodeCreateManyTeamInputEnvelope
    set?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    disconnect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    delete?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    connect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    update?: TeamJoinCodeUpdateWithWhereUniqueWithoutTeamInput | TeamJoinCodeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamJoinCodeUpdateManyWithWhereWithoutTeamInput | TeamJoinCodeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamJoinCodeScalarWhereInput | TeamJoinCodeScalarWhereInput[]
  }

  export type TeamLinkUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput> | TeamLinkCreateWithoutTeamInput[] | TeamLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLinkCreateOrConnectWithoutTeamInput | TeamLinkCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLinkUpsertWithWhereUniqueWithoutTeamInput | TeamLinkUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLinkCreateManyTeamInputEnvelope
    set?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    disconnect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    delete?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    connect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    update?: TeamLinkUpdateWithWhereUniqueWithoutTeamInput | TeamLinkUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLinkUpdateManyWithWhereWithoutTeamInput | TeamLinkUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLinkScalarWhereInput | TeamLinkScalarWhereInput[]
  }

  export type TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutTeamInput | TeamMembershipUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutTeamInput | TeamMembershipUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutTeamInput | TeamMembershipUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput> | GoalCreateWithoutTeamInput[] | GoalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutTeamInput | GoalCreateOrConnectWithoutTeamInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutTeamInput | GoalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: GoalCreateManyTeamInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutTeamInput | GoalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutTeamInput | GoalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput> | CalendarEventCreateWithoutTeamInput[] | CalendarEventUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTeamInput | CalendarEventCreateOrConnectWithoutTeamInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTeamInput | CalendarEventUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CalendarEventCreateManyTeamInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTeamInput | CalendarEventUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTeamInput | CalendarEventUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput> | TeamJoinCodeCreateWithoutTeamInput[] | TeamJoinCodeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinCodeCreateOrConnectWithoutTeamInput | TeamJoinCodeCreateOrConnectWithoutTeamInput[]
    upsert?: TeamJoinCodeUpsertWithWhereUniqueWithoutTeamInput | TeamJoinCodeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamJoinCodeCreateManyTeamInputEnvelope
    set?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    disconnect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    delete?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    connect?: TeamJoinCodeWhereUniqueInput | TeamJoinCodeWhereUniqueInput[]
    update?: TeamJoinCodeUpdateWithWhereUniqueWithoutTeamInput | TeamJoinCodeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamJoinCodeUpdateManyWithWhereWithoutTeamInput | TeamJoinCodeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamJoinCodeScalarWhereInput | TeamJoinCodeScalarWhereInput[]
  }

  export type TeamLinkUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput> | TeamLinkCreateWithoutTeamInput[] | TeamLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLinkCreateOrConnectWithoutTeamInput | TeamLinkCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLinkUpsertWithWhereUniqueWithoutTeamInput | TeamLinkUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLinkCreateManyTeamInputEnvelope
    set?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    disconnect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    delete?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    connect?: TeamLinkWhereUniqueInput | TeamLinkWhereUniqueInput[]
    update?: TeamLinkUpdateWithWhereUniqueWithoutTeamInput | TeamLinkUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLinkUpdateManyWithWhereWithoutTeamInput | TeamLinkUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLinkScalarWhereInput | TeamLinkScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutLinksInput = {
    create?: XOR<TeamCreateWithoutLinksInput, TeamUncheckedCreateWithoutLinksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLinksInput
    connect?: TeamWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<TeamCreateWithoutLinksInput, TeamUncheckedCreateWithoutLinksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLinksInput
    upsert?: TeamUpsertWithoutLinksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutLinksInput, TeamUpdateWithoutLinksInput>, TeamUncheckedUpdateWithoutLinksInput>
  }

  export type TeamCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<TeamCreateWithoutMembershipsInput, TeamUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembershipsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<TeamCreateWithoutMembershipsInput, TeamUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembershipsInput
    upsert?: TeamUpsertWithoutMembershipsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembershipsInput, TeamUpdateWithoutMembershipsInput>, TeamUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type TeamCreateNestedOneWithoutJoinCodesInput = {
    create?: XOR<TeamCreateWithoutJoinCodesInput, TeamUncheckedCreateWithoutJoinCodesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutJoinCodesInput
    connect?: TeamWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamUpdateOneRequiredWithoutJoinCodesNestedInput = {
    create?: XOR<TeamCreateWithoutJoinCodesInput, TeamUncheckedCreateWithoutJoinCodesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutJoinCodesInput
    upsert?: TeamUpsertWithoutJoinCodesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutJoinCodesInput, TeamUpdateWithoutJoinCodesInput>, TeamUncheckedUpdateWithoutJoinCodesInput>
  }

  export type OrganizationCreateNestedOneWithoutOrgJoinCodesInput = {
    create?: XOR<OrganizationCreateWithoutOrgJoinCodesInput, OrganizationUncheckedCreateWithoutOrgJoinCodesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrgJoinCodesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutOrgJoinCodesNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrgJoinCodesInput, OrganizationUncheckedCreateWithoutOrgJoinCodesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrgJoinCodesInput
    upsert?: OrganizationUpsertWithoutOrgJoinCodesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrgJoinCodesInput, OrganizationUpdateWithoutOrgJoinCodesInput>, OrganizationUncheckedUpdateWithoutOrgJoinCodesInput>
  }

  export type TeamCreateNestedOneWithoutGoalsInput = {
    create?: XOR<TeamCreateWithoutGoalsInput, TeamUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutGoalsInput
    connect?: TeamWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutGoalInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TeamUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<TeamCreateWithoutGoalsInput, TeamUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutGoalsInput
    upsert?: TeamUpsertWithoutGoalsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutGoalsInput, TeamUpdateWithoutGoalsInput>, TeamUncheckedUpdateWithoutGoalsInput>
  }

  export type TaskUpdateManyWithoutGoalNestedInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoalInput | TaskUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoalInput | TaskUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoalInput | TaskUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoalInput | TaskUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoalInput | TaskUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoalInput | TaskUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutTasksInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    connect?: TeamWhereUniqueInput
  }

  export type GoalCreateNestedOneWithoutTasksInput = {
    create?: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoalCreateOrConnectWithoutTasksInput
    connect?: GoalWhereUniqueInput
  }

  export type TaskAssignmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskNoteCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutTaskInput = {
    create?: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput> | CalendarEventCreateWithoutTaskInput[] | CalendarEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTaskInput | CalendarEventCreateOrConnectWithoutTaskInput[]
    createMany?: CalendarEventCreateManyTaskInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type TaskNoteUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput> | CalendarEventCreateWithoutTaskInput[] | CalendarEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTaskInput | CalendarEventCreateOrConnectWithoutTaskInput[]
    createMany?: CalendarEventCreateManyTaskInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type TeamUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    upsert?: TeamUpsertWithoutTasksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTasksInput, TeamUpdateWithoutTasksInput>, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type GoalUpdateOneWithoutTasksNestedInput = {
    create?: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoalCreateOrConnectWithoutTasksInput
    upsert?: GoalUpsertWithoutTasksInput
    disconnect?: GoalWhereInput | boolean
    delete?: GoalWhereInput | boolean
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutTasksInput, GoalUpdateWithoutTasksInput>, GoalUncheckedUpdateWithoutTasksInput>
  }

  export type TaskAssignmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskNoteUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutTaskInput | TaskNoteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutTaskInput | TaskNoteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutTaskInput | TaskNoteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput> | CalendarEventCreateWithoutTaskInput[] | CalendarEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTaskInput | CalendarEventCreateOrConnectWithoutTaskInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTaskInput | CalendarEventUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CalendarEventCreateManyTaskInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTaskInput | CalendarEventUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTaskInput | CalendarEventUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput> | TaskAssignmentCreateWithoutTaskInput[] | TaskAssignmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput | TaskAssignmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput | TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssignmentCreateManyTaskInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput | TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutTaskInput | TaskAssignmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type TaskNoteUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutTaskInput | TaskNoteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutTaskInput | TaskNoteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutTaskInput | TaskNoteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput> | CalendarEventCreateWithoutTaskInput[] | CalendarEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutTaskInput | CalendarEventCreateOrConnectWithoutTaskInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutTaskInput | CalendarEventUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CalendarEventCreateManyTaskInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutTaskInput | CalendarEventUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutTaskInput | CalendarEventUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskAssignmentInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentInput, UserUncheckedCreateWithoutTaskAssignmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    upsert?: TaskUpsertWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAssigneesInput, TaskUpdateWithoutAssigneesInput>, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type UserUpdateOneRequiredWithoutTaskAssignmentNestedInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentInput, UserUncheckedCreateWithoutTaskAssignmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentInput
    upsert?: UserUpsertWithoutTaskAssignmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskAssignmentInput, UserUpdateWithoutTaskAssignmentInput>, UserUncheckedUpdateWithoutTaskAssignmentInput>
  }

  export type TaskCreateNestedOneWithoutNotesInput = {
    create?: XOR<TaskCreateWithoutNotesInput, TaskUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutNotesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type TaskNoteMentionCreateNestedManyWithoutNoteInput = {
    create?: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput> | TaskNoteMentionCreateWithoutNoteInput[] | TaskNoteMentionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutNoteInput | TaskNoteMentionCreateOrConnectWithoutNoteInput[]
    createMany?: TaskNoteMentionCreateManyNoteInputEnvelope
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
  }

  export type TaskNoteMentionUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput> | TaskNoteMentionCreateWithoutNoteInput[] | TaskNoteMentionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutNoteInput | TaskNoteMentionCreateOrConnectWithoutNoteInput[]
    createMany?: TaskNoteMentionCreateManyNoteInputEnvelope
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
  }

  export type TaskUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<TaskCreateWithoutNotesInput, TaskUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutNotesInput
    upsert?: TaskUpsertWithoutNotesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutNotesInput, TaskUpdateWithoutNotesInput>, TaskUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type TaskNoteMentionUpdateManyWithoutNoteNestedInput = {
    create?: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput> | TaskNoteMentionCreateWithoutNoteInput[] | TaskNoteMentionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutNoteInput | TaskNoteMentionCreateOrConnectWithoutNoteInput[]
    upsert?: TaskNoteMentionUpsertWithWhereUniqueWithoutNoteInput | TaskNoteMentionUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: TaskNoteMentionCreateManyNoteInputEnvelope
    set?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    disconnect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    delete?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    update?: TaskNoteMentionUpdateWithWhereUniqueWithoutNoteInput | TaskNoteMentionUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: TaskNoteMentionUpdateManyWithWhereWithoutNoteInput | TaskNoteMentionUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
  }

  export type TaskNoteMentionUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput> | TaskNoteMentionCreateWithoutNoteInput[] | TaskNoteMentionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: TaskNoteMentionCreateOrConnectWithoutNoteInput | TaskNoteMentionCreateOrConnectWithoutNoteInput[]
    upsert?: TaskNoteMentionUpsertWithWhereUniqueWithoutNoteInput | TaskNoteMentionUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: TaskNoteMentionCreateManyNoteInputEnvelope
    set?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    disconnect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    delete?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    connect?: TaskNoteMentionWhereUniqueInput | TaskNoteMentionWhereUniqueInput[]
    update?: TaskNoteMentionUpdateWithWhereUniqueWithoutNoteInput | TaskNoteMentionUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: TaskNoteMentionUpdateManyWithWhereWithoutNoteInput | TaskNoteMentionUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
  }

  export type TaskNoteCreateNestedOneWithoutMentionsInput = {
    create?: XOR<TaskNoteCreateWithoutMentionsInput, TaskNoteUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: TaskNoteCreateOrConnectWithoutMentionsInput
    connect?: TaskNoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskNoteMentionInput = {
    create?: XOR<UserCreateWithoutTaskNoteMentionInput, UserUncheckedCreateWithoutTaskNoteMentionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNoteMentionInput
    connect?: UserWhereUniqueInput
  }

  export type TaskNoteUpdateOneRequiredWithoutMentionsNestedInput = {
    create?: XOR<TaskNoteCreateWithoutMentionsInput, TaskNoteUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: TaskNoteCreateOrConnectWithoutMentionsInput
    upsert?: TaskNoteUpsertWithoutMentionsInput
    connect?: TaskNoteWhereUniqueInput
    update?: XOR<XOR<TaskNoteUpdateToOneWithWhereWithoutMentionsInput, TaskNoteUpdateWithoutMentionsInput>, TaskNoteUncheckedUpdateWithoutMentionsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskNoteMentionNestedInput = {
    create?: XOR<UserCreateWithoutTaskNoteMentionInput, UserUncheckedCreateWithoutTaskNoteMentionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNoteMentionInput
    upsert?: UserUpsertWithoutTaskNoteMentionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskNoteMentionInput, UserUpdateWithoutTaskNoteMentionInput>, UserUncheckedUpdateWithoutTaskNoteMentionInput>
  }

  export type TeamCreateNestedOneWithoutEventsInput = {
    create?: XOR<TeamCreateWithoutEventsInput, TeamUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEventsInput
    connect?: TeamWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<TaskCreateWithoutCalendarEventsInput, TaskUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCalendarEventsInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumCalendarItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarItemType
  }

  export type TeamUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<TeamCreateWithoutEventsInput, TeamUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEventsInput
    upsert?: TeamUpsertWithoutEventsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutEventsInput, TeamUpdateWithoutEventsInput>, TeamUncheckedUpdateWithoutEventsInput>
  }

  export type TaskUpdateOneWithoutCalendarEventsNestedInput = {
    create?: XOR<TaskCreateWithoutCalendarEventsInput, TaskUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCalendarEventsInput
    upsert?: TaskUpsertWithoutCalendarEventsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCalendarEventsInput, TaskUpdateWithoutCalendarEventsInput>, TaskUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }

  export type NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumCalendarItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarItemType | EnumCalendarItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarItemTypeFilter<$PrismaModel> | $Enums.CalendarItemType
  }

  export type NestedEnumCalendarItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarItemType | EnumCalendarItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarItemType[] | ListEnumCalendarItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarItemTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarItemTypeFilter<$PrismaModel>
  }

  export type IdentityCreateWithoutUserInput = {
    id?: string
    provider: string
    providerId: string
  }

  export type IdentityUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerId: string
  }

  export type IdentityCreateOrConnectWithoutUserInput = {
    where: IdentityWhereUniqueInput
    create: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput>
  }

  export type IdentityCreateManyUserInputEnvelope = {
    data: IdentityCreateManyUserInput | IdentityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrgMembershipCreateWithoutUserInput = {
    id?: string
    role: $Enums.OrgRole
    org: OrganizationCreateNestedOneWithoutMembershipsInput
  }

  export type OrgMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    orgId: string
    role: $Enums.OrgRole
  }

  export type OrgMembershipCreateOrConnectWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput
    create: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrgMembershipCreateManyUserInputEnvelope = {
    data: OrgMembershipCreateManyUserInput | OrgMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMembershipCreateWithoutUserInput = {
    id?: string
    role?: $Enums.TeamRole
    team: TeamCreateNestedOneWithoutMembershipsInput
  }

  export type TeamMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
  }

  export type TeamMembershipCreateOrConnectWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput>
  }

  export type TeamMembershipCreateManyUserInputEnvelope = {
    data: TeamMembershipCreateManyUserInput | TeamMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskNoteCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutNotesInput
    mentions?: TaskNoteMentionCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
    mentions?: TaskNoteMentionUncheckedCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteCreateOrConnectWithoutAuthorInput = {
    where: TaskNoteWhereUniqueInput
    create: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput>
  }

  export type TaskNoteCreateManyAuthorInputEnvelope = {
    data: TaskNoteCreateManyAuthorInput | TaskNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssignmentCreateWithoutUserInput = {
    id?: string
    task: TaskCreateNestedOneWithoutAssigneesInput
  }

  export type TaskAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
  }

  export type TaskAssignmentCreateOrConnectWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput>
  }

  export type TaskAssignmentCreateManyUserInputEnvelope = {
    data: TaskAssignmentCreateManyUserInput | TaskAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskNoteMentionCreateWithoutUserInput = {
    id?: string
    note: TaskNoteCreateNestedOneWithoutMentionsInput
  }

  export type TaskNoteMentionUncheckedCreateWithoutUserInput = {
    id?: string
    noteId: string
  }

  export type TaskNoteMentionCreateOrConnectWithoutUserInput = {
    where: TaskNoteMentionWhereUniqueInput
    create: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput>
  }

  export type TaskNoteMentionCreateManyUserInputEnvelope = {
    data: TaskNoteMentionCreateManyUserInput | TaskNoteMentionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IdentityUpsertWithWhereUniqueWithoutUserInput = {
    where: IdentityWhereUniqueInput
    update: XOR<IdentityUpdateWithoutUserInput, IdentityUncheckedUpdateWithoutUserInput>
    create: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput>
  }

  export type IdentityUpdateWithWhereUniqueWithoutUserInput = {
    where: IdentityWhereUniqueInput
    data: XOR<IdentityUpdateWithoutUserInput, IdentityUncheckedUpdateWithoutUserInput>
  }

  export type IdentityUpdateManyWithWhereWithoutUserInput = {
    where: IdentityScalarWhereInput
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyWithoutUserInput>
  }

  export type IdentityScalarWhereInput = {
    AND?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
    OR?: IdentityScalarWhereInput[]
    NOT?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
    id?: StringFilter<"Identity"> | string
    userId?: StringFilter<"Identity"> | string
    provider?: StringFilter<"Identity"> | string
    providerId?: StringFilter<"Identity"> | string
  }

  export type OrgMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput
    update: XOR<OrgMembershipUpdateWithoutUserInput, OrgMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<OrgMembershipCreateWithoutUserInput, OrgMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrgMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput
    data: XOR<OrgMembershipUpdateWithoutUserInput, OrgMembershipUncheckedUpdateWithoutUserInput>
  }

  export type OrgMembershipUpdateManyWithWhereWithoutUserInput = {
    where: OrgMembershipScalarWhereInput
    data: XOR<OrgMembershipUpdateManyMutationInput, OrgMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type OrgMembershipScalarWhereInput = {
    AND?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
    OR?: OrgMembershipScalarWhereInput[]
    NOT?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[]
    id?: StringFilter<"OrgMembership"> | string
    orgId?: StringFilter<"OrgMembership"> | string
    userId?: StringFilter<"OrgMembership"> | string
    role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUpdateWithoutUserInput, TeamMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUpdateWithoutUserInput, TeamMembershipUncheckedUpdateWithoutUserInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutUserInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMembershipScalarWhereInput = {
    AND?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
    OR?: TeamMembershipScalarWhereInput[]
    NOT?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
    id?: StringFilter<"TeamMembership"> | string
    teamId?: StringFilter<"TeamMembership"> | string
    userId?: StringFilter<"TeamMembership"> | string
    role?: EnumTeamRoleFilter<"TeamMembership"> | $Enums.TeamRole
  }

  export type TaskNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TaskNoteWhereUniqueInput
    update: XOR<TaskNoteUpdateWithoutAuthorInput, TaskNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<TaskNoteCreateWithoutAuthorInput, TaskNoteUncheckedCreateWithoutAuthorInput>
  }

  export type TaskNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TaskNoteWhereUniqueInput
    data: XOR<TaskNoteUpdateWithoutAuthorInput, TaskNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type TaskNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: TaskNoteScalarWhereInput
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TaskNoteScalarWhereInput = {
    AND?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
    OR?: TaskNoteScalarWhereInput[]
    NOT?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
    id?: StringFilter<"TaskNote"> | string
    taskId?: StringFilter<"TaskNote"> | string
    authorId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutUserInput, TaskAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<TaskAssignmentCreateWithoutUserInput, TaskAssignmentUncheckedCreateWithoutUserInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutUserInput, TaskAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskAssignmentScalarWhereInput = {
    AND?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    OR?: TaskAssignmentScalarWhereInput[]
    NOT?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    taskId?: StringFilter<"TaskAssignment"> | string
    userId?: StringFilter<"TaskAssignment"> | string
  }

  export type TaskNoteMentionUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskNoteMentionWhereUniqueInput
    update: XOR<TaskNoteMentionUpdateWithoutUserInput, TaskNoteMentionUncheckedUpdateWithoutUserInput>
    create: XOR<TaskNoteMentionCreateWithoutUserInput, TaskNoteMentionUncheckedCreateWithoutUserInput>
  }

  export type TaskNoteMentionUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskNoteMentionWhereUniqueInput
    data: XOR<TaskNoteMentionUpdateWithoutUserInput, TaskNoteMentionUncheckedUpdateWithoutUserInput>
  }

  export type TaskNoteMentionUpdateManyWithWhereWithoutUserInput = {
    where: TaskNoteMentionScalarWhereInput
    data: XOR<TaskNoteMentionUpdateManyMutationInput, TaskNoteMentionUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskNoteMentionScalarWhereInput = {
    AND?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
    OR?: TaskNoteMentionScalarWhereInput[]
    NOT?: TaskNoteMentionScalarWhereInput | TaskNoteMentionScalarWhereInput[]
    id?: StringFilter<"TaskNoteMention"> | string
    noteId?: StringFilter<"TaskNoteMention"> | string
    userId?: StringFilter<"TaskNoteMention"> | string
  }

  export type UserCreateWithoutIdentitiesInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdentitiesInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdentitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
  }

  export type UserUpsertWithoutIdentitiesInput = {
    update: XOR<UserUpdateWithoutIdentitiesInput, UserUncheckedUpdateWithoutIdentitiesInput>
    create: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIdentitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIdentitiesInput, UserUncheckedUpdateWithoutIdentitiesInput>
  }

  export type UserUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrgMembershipCreateWithoutOrgInput = {
    id?: string
    role: $Enums.OrgRole
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type OrgMembershipUncheckedCreateWithoutOrgInput = {
    id?: string
    userId: string
    role: $Enums.OrgRole
  }

  export type OrgMembershipCreateOrConnectWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput
    create: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput>
  }

  export type OrgMembershipCreateManyOrgInputEnvelope = {
    data: OrgMembershipCreateManyOrgInput | OrgMembershipCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOrgInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrgInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrgInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput>
  }

  export type TeamCreateManyOrgInputEnvelope = {
    data: TeamCreateManyOrgInput | TeamCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type OrgJoinCodeCreateWithoutOrgInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
  }

  export type OrgJoinCodeUncheckedCreateWithoutOrgInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
  }

  export type OrgJoinCodeCreateOrConnectWithoutOrgInput = {
    where: OrgJoinCodeWhereUniqueInput
    create: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput>
  }

  export type OrgJoinCodeCreateManyOrgInputEnvelope = {
    data: OrgJoinCodeCreateManyOrgInput | OrgJoinCodeCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type OrgMembershipUpsertWithWhereUniqueWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput
    update: XOR<OrgMembershipUpdateWithoutOrgInput, OrgMembershipUncheckedUpdateWithoutOrgInput>
    create: XOR<OrgMembershipCreateWithoutOrgInput, OrgMembershipUncheckedCreateWithoutOrgInput>
  }

  export type OrgMembershipUpdateWithWhereUniqueWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput
    data: XOR<OrgMembershipUpdateWithoutOrgInput, OrgMembershipUncheckedUpdateWithoutOrgInput>
  }

  export type OrgMembershipUpdateManyWithWhereWithoutOrgInput = {
    where: OrgMembershipScalarWhereInput
    data: XOR<OrgMembershipUpdateManyMutationInput, OrgMembershipUncheckedUpdateManyWithoutOrgInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutOrgInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOrgInput, TeamUncheckedUpdateWithoutOrgInput>
    create: XOR<TeamCreateWithoutOrgInput, TeamUncheckedCreateWithoutOrgInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOrgInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOrgInput, TeamUncheckedUpdateWithoutOrgInput>
  }

  export type TeamUpdateManyWithWhereWithoutOrgInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOrgInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    orgId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    createdBy?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    info?: StringNullableFilter<"Team"> | string | null
  }

  export type OrgJoinCodeUpsertWithWhereUniqueWithoutOrgInput = {
    where: OrgJoinCodeWhereUniqueInput
    update: XOR<OrgJoinCodeUpdateWithoutOrgInput, OrgJoinCodeUncheckedUpdateWithoutOrgInput>
    create: XOR<OrgJoinCodeCreateWithoutOrgInput, OrgJoinCodeUncheckedCreateWithoutOrgInput>
  }

  export type OrgJoinCodeUpdateWithWhereUniqueWithoutOrgInput = {
    where: OrgJoinCodeWhereUniqueInput
    data: XOR<OrgJoinCodeUpdateWithoutOrgInput, OrgJoinCodeUncheckedUpdateWithoutOrgInput>
  }

  export type OrgJoinCodeUpdateManyWithWhereWithoutOrgInput = {
    where: OrgJoinCodeScalarWhereInput
    data: XOR<OrgJoinCodeUpdateManyMutationInput, OrgJoinCodeUncheckedUpdateManyWithoutOrgInput>
  }

  export type OrgJoinCodeScalarWhereInput = {
    AND?: OrgJoinCodeScalarWhereInput | OrgJoinCodeScalarWhereInput[]
    OR?: OrgJoinCodeScalarWhereInput[]
    NOT?: OrgJoinCodeScalarWhereInput | OrgJoinCodeScalarWhereInput[]
    id?: StringFilter<"OrgJoinCode"> | string
    orgId?: StringFilter<"OrgJoinCode"> | string
    code?: StringFilter<"OrgJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"OrgJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"OrgJoinCode"> | number | null
    uses?: IntFilter<"OrgJoinCode"> | number
    createdAt?: DateTimeFilter<"OrgJoinCode"> | Date | string
  }

  export type OrganizationCreateWithoutMembershipsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    teams?: TeamCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutMembershipsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type OrganizationUpsertWithoutMembershipsInput = {
    update: XOR<OrganizationUpdateWithoutMembershipsInput, OrganizationUncheckedUpdateWithoutMembershipsInput>
    create: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembershipsInput, OrganizationUncheckedUpdateWithoutMembershipsInput>
  }

  export type OrganizationUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutTeamsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutOrgInput
    orgJoinCodes?: OrgJoinCodeUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutTeamsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
  }

  export type TeamMembershipCreateWithoutTeamInput = {
    id?: string
    role?: $Enums.TeamRole
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMembershipUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
  }

  export type TeamMembershipCreateOrConnectWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput>
  }

  export type TeamMembershipCreateManyTeamInputEnvelope = {
    data: TeamMembershipCreateManyTeamInput | TeamMembershipCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutTeamInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput>
  }

  export type GoalCreateManyTeamInputEnvelope = {
    data: GoalCreateManyTeamInput | GoalCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    goal?: GoalCreateNestedOneWithoutTasksInput
    assignees?: TaskAssignmentCreateNestedManyWithoutTaskInput
    notes?: TaskNoteCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTeamInput = {
    id?: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    assignees?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTeamInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskCreateManyTeamInputEnvelope = {
    data: TaskCreateManyTeamInput | TaskCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    task?: TaskCreateNestedOneWithoutCalendarEventsInput
  }

  export type CalendarEventUncheckedCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    relatedTaskId?: string | null
  }

  export type CalendarEventCreateOrConnectWithoutTeamInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput>
  }

  export type CalendarEventCreateManyTeamInputEnvelope = {
    data: CalendarEventCreateManyTeamInput | CalendarEventCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamJoinCodeCreateWithoutTeamInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
  }

  export type TeamJoinCodeUncheckedCreateWithoutTeamInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
  }

  export type TeamJoinCodeCreateOrConnectWithoutTeamInput = {
    where: TeamJoinCodeWhereUniqueInput
    create: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput>
  }

  export type TeamJoinCodeCreateManyTeamInputEnvelope = {
    data: TeamJoinCodeCreateManyTeamInput | TeamJoinCodeCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamLinkCreateWithoutTeamInput = {
    id?: string
    label: string
    url: string
    ordinal?: number
  }

  export type TeamLinkUncheckedCreateWithoutTeamInput = {
    id?: string
    label: string
    url: string
    ordinal?: number
  }

  export type TeamLinkCreateOrConnectWithoutTeamInput = {
    where: TeamLinkWhereUniqueInput
    create: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput>
  }

  export type TeamLinkCreateManyTeamInputEnvelope = {
    data: TeamLinkCreateManyTeamInput | TeamLinkCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutTeamsInput = {
    update: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeamsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type OrganizationUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput
    orgJoinCodes?: OrgJoinCodeUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUpdateWithoutTeamInput, TeamMembershipUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUpdateWithoutTeamInput, TeamMembershipUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyWithoutTeamInput>
  }

  export type GoalUpsertWithWhereUniqueWithoutTeamInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutTeamInput, GoalUncheckedUpdateWithoutTeamInput>
    create: XOR<GoalCreateWithoutTeamInput, GoalUncheckedCreateWithoutTeamInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutTeamInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutTeamInput, GoalUncheckedUpdateWithoutTeamInput>
  }

  export type GoalUpdateManyWithWhereWithoutTeamInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutTeamInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    teamId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
  }

  export type TaskUpdateManyWithWhereWithoutTeamInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTeamInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    teamId?: StringFilter<"Task"> | string
    goalId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdBy?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutTeamInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutTeamInput, CalendarEventUncheckedUpdateWithoutTeamInput>
    create: XOR<CalendarEventCreateWithoutTeamInput, CalendarEventUncheckedCreateWithoutTeamInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutTeamInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutTeamInput, CalendarEventUncheckedUpdateWithoutTeamInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutTeamInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutTeamInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    teamId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: EnumCalendarItemTypeFilter<"CalendarEvent"> | $Enums.CalendarItemType
    startAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    endAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    googleEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    googleCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncedAt?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    relatedTaskId?: StringNullableFilter<"CalendarEvent"> | string | null
  }

  export type TeamJoinCodeUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinCodeWhereUniqueInput
    update: XOR<TeamJoinCodeUpdateWithoutTeamInput, TeamJoinCodeUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamJoinCodeCreateWithoutTeamInput, TeamJoinCodeUncheckedCreateWithoutTeamInput>
  }

  export type TeamJoinCodeUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinCodeWhereUniqueInput
    data: XOR<TeamJoinCodeUpdateWithoutTeamInput, TeamJoinCodeUncheckedUpdateWithoutTeamInput>
  }

  export type TeamJoinCodeUpdateManyWithWhereWithoutTeamInput = {
    where: TeamJoinCodeScalarWhereInput
    data: XOR<TeamJoinCodeUpdateManyMutationInput, TeamJoinCodeUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamJoinCodeScalarWhereInput = {
    AND?: TeamJoinCodeScalarWhereInput | TeamJoinCodeScalarWhereInput[]
    OR?: TeamJoinCodeScalarWhereInput[]
    NOT?: TeamJoinCodeScalarWhereInput | TeamJoinCodeScalarWhereInput[]
    id?: StringFilter<"TeamJoinCode"> | string
    teamId?: StringFilter<"TeamJoinCode"> | string
    code?: StringFilter<"TeamJoinCode"> | string
    expiresAt?: DateTimeNullableFilter<"TeamJoinCode"> | Date | string | null
    maxUses?: IntNullableFilter<"TeamJoinCode"> | number | null
    uses?: IntFilter<"TeamJoinCode"> | number
  }

  export type TeamLinkUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamLinkWhereUniqueInput
    update: XOR<TeamLinkUpdateWithoutTeamInput, TeamLinkUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamLinkCreateWithoutTeamInput, TeamLinkUncheckedCreateWithoutTeamInput>
  }

  export type TeamLinkUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamLinkWhereUniqueInput
    data: XOR<TeamLinkUpdateWithoutTeamInput, TeamLinkUncheckedUpdateWithoutTeamInput>
  }

  export type TeamLinkUpdateManyWithWhereWithoutTeamInput = {
    where: TeamLinkScalarWhereInput
    data: XOR<TeamLinkUpdateManyMutationInput, TeamLinkUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamLinkScalarWhereInput = {
    AND?: TeamLinkScalarWhereInput | TeamLinkScalarWhereInput[]
    OR?: TeamLinkScalarWhereInput[]
    NOT?: TeamLinkScalarWhereInput | TeamLinkScalarWhereInput[]
    id?: StringFilter<"TeamLink"> | string
    teamId?: StringFilter<"TeamLink"> | string
    label?: StringFilter<"TeamLink"> | string
    url?: StringFilter<"TeamLink"> | string
    ordinal?: IntFilter<"TeamLink"> | number
  }

  export type TeamCreateWithoutLinksInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLinksInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLinksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLinksInput, TeamUncheckedCreateWithoutLinksInput>
  }

  export type TeamUpsertWithoutLinksInput = {
    update: XOR<TeamUpdateWithoutLinksInput, TeamUncheckedUpdateWithoutLinksInput>
    create: XOR<TeamCreateWithoutLinksInput, TeamUncheckedCreateWithoutLinksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutLinksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutLinksInput, TeamUncheckedUpdateWithoutLinksInput>
  }

  export type TeamUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutMembershipsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembershipsInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembershipsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembershipsInput, TeamUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembershipsInput = {
    update: XOR<TeamUpdateWithoutMembershipsInput, TeamUncheckedUpdateWithoutMembershipsInput>
    create: XOR<TeamCreateWithoutMembershipsInput, TeamUncheckedCreateWithoutMembershipsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembershipsInput, TeamUncheckedUpdateWithoutMembershipsInput>
  }

  export type TeamUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutJoinCodesInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutJoinCodesInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutJoinCodesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutJoinCodesInput, TeamUncheckedCreateWithoutJoinCodesInput>
  }

  export type TeamUpsertWithoutJoinCodesInput = {
    update: XOR<TeamUpdateWithoutJoinCodesInput, TeamUncheckedUpdateWithoutJoinCodesInput>
    create: XOR<TeamCreateWithoutJoinCodesInput, TeamUncheckedCreateWithoutJoinCodesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutJoinCodesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutJoinCodesInput, TeamUncheckedUpdateWithoutJoinCodesInput>
  }

  export type TeamUpdateWithoutJoinCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutJoinCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type OrganizationCreateWithoutOrgJoinCodesInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipCreateNestedManyWithoutOrgInput
    teams?: TeamCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutOrgJoinCodesInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutOrgInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutOrgJoinCodesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrgJoinCodesInput, OrganizationUncheckedCreateWithoutOrgJoinCodesInput>
  }

  export type OrganizationUpsertWithoutOrgJoinCodesInput = {
    update: XOR<OrganizationUpdateWithoutOrgJoinCodesInput, OrganizationUncheckedUpdateWithoutOrgJoinCodesInput>
    create: XOR<OrganizationCreateWithoutOrgJoinCodesInput, OrganizationUncheckedCreateWithoutOrgJoinCodesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrgJoinCodesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrgJoinCodesInput, OrganizationUncheckedUpdateWithoutOrgJoinCodesInput>
  }

  export type OrganizationUpdateWithoutOrgJoinCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUpdateManyWithoutOrgNestedInput
    teams?: TeamUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrgJoinCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type TeamCreateWithoutGoalsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutGoalsInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutGoalsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutGoalsInput, TeamUncheckedCreateWithoutGoalsInput>
  }

  export type TaskCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTasksInput
    assignees?: TaskAssignmentCreateNestedManyWithoutTaskInput
    notes?: TaskNoteCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutGoalInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    assignees?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutGoalInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput>
  }

  export type TaskCreateManyGoalInputEnvelope = {
    data: TaskCreateManyGoalInput | TaskCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutGoalsInput = {
    update: XOR<TeamUpdateWithoutGoalsInput, TeamUncheckedUpdateWithoutGoalsInput>
    create: XOR<TeamCreateWithoutGoalsInput, TeamUncheckedCreateWithoutGoalsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutGoalsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutGoalsInput, TeamUncheckedUpdateWithoutGoalsInput>
  }

  export type TeamUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutGoalInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutGoalInput, TaskUncheckedUpdateWithoutGoalInput>
    create: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutGoalInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutGoalInput, TaskUncheckedUpdateWithoutGoalInput>
  }

  export type TaskUpdateManyWithWhereWithoutGoalInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutGoalInput>
  }

  export type TeamCreateWithoutTasksInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    events?: CalendarEventCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTasksInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTasksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
  }

  export type GoalCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
    team: TeamCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateWithoutTasksInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
  }

  export type GoalCreateOrConnectWithoutTasksInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
  }

  export type TaskAssignmentCreateWithoutTaskInput = {
    id?: string
    user: UserCreateNestedOneWithoutTaskAssignmentInput
  }

  export type TaskAssignmentUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
  }

  export type TaskAssignmentCreateOrConnectWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentCreateManyTaskInputEnvelope = {
    data: TaskAssignmentCreateManyTaskInput | TaskAssignmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskNoteCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutNotesInput
    mentions?: TaskNoteMentionCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteUncheckedCreateWithoutTaskInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    mentions?: TaskNoteMentionUncheckedCreateNestedManyWithoutNoteInput
  }

  export type TaskNoteCreateOrConnectWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    create: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput>
  }

  export type TaskNoteCreateManyTaskInputEnvelope = {
    data: TaskNoteCreateManyTaskInput | TaskNoteCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutTaskInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutEventsInput
  }

  export type CalendarEventUncheckedCreateWithoutTaskInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutTaskInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput>
  }

  export type CalendarEventCreateManyTaskInputEnvelope = {
    data: CalendarEventCreateManyTaskInput | CalendarEventCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutTasksInput = {
    update: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTasksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type TeamUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type GoalUpsertWithoutTasksInput = {
    update: XOR<GoalUpdateWithoutTasksInput, GoalUncheckedUpdateWithoutTasksInput>
    create: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutTasksInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutTasksInput, GoalUncheckedUpdateWithoutTasksInput>
  }

  export type GoalUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskNoteUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    update: XOR<TaskNoteUpdateWithoutTaskInput, TaskNoteUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput>
  }

  export type TaskNoteUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    data: XOR<TaskNoteUpdateWithoutTaskInput, TaskNoteUncheckedUpdateWithoutTaskInput>
  }

  export type TaskNoteUpdateManyWithWhereWithoutTaskInput = {
    where: TaskNoteScalarWhereInput
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyWithoutTaskInput>
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutTaskInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutTaskInput, CalendarEventUncheckedUpdateWithoutTaskInput>
    create: XOR<CalendarEventCreateWithoutTaskInput, CalendarEventUncheckedCreateWithoutTaskInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutTaskInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutTaskInput, CalendarEventUncheckedUpdateWithoutTaskInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutTaskInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCreateWithoutAssigneesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTasksInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    notes?: TaskNoteCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneesInput = {
    id?: string
    teamId: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    notes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
  }

  export type UserCreateWithoutTaskAssignmentInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskAssignmentInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskAssignmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskAssignmentInput, UserUncheckedCreateWithoutTaskAssignmentInput>
  }

  export type TaskUpsertWithoutAssigneesInput = {
    update: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    notes?: TaskNoteUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskAssignmentInput = {
    update: XOR<UserUpdateWithoutTaskAssignmentInput, UserUncheckedUpdateWithoutTaskAssignmentInput>
    create: XOR<UserCreateWithoutTaskAssignmentInput, UserUncheckedCreateWithoutTaskAssignmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskAssignmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskAssignmentInput, UserUncheckedUpdateWithoutTaskAssignmentInput>
  }

  export type UserUpdateWithoutTaskAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskCreateWithoutNotesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTasksInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    assignees?: TaskAssignmentCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutNotesInput = {
    id?: string
    teamId: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    assignees?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutNotesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutNotesInput, TaskUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
    TaskNoteMention?: TaskNoteMentionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type TaskNoteMentionCreateWithoutNoteInput = {
    id?: string
    user: UserCreateNestedOneWithoutTaskNoteMentionInput
  }

  export type TaskNoteMentionUncheckedCreateWithoutNoteInput = {
    id?: string
    userId: string
  }

  export type TaskNoteMentionCreateOrConnectWithoutNoteInput = {
    where: TaskNoteMentionWhereUniqueInput
    create: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput>
  }

  export type TaskNoteMentionCreateManyNoteInputEnvelope = {
    data: TaskNoteMentionCreateManyNoteInput | TaskNoteMentionCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithoutNotesInput = {
    update: XOR<TaskUpdateWithoutNotesInput, TaskUncheckedUpdateWithoutNotesInput>
    create: XOR<TaskCreateWithoutNotesInput, TaskUncheckedCreateWithoutNotesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutNotesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutNotesInput, TaskUncheckedUpdateWithoutNotesInput>
  }

  export type TaskUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
    TaskNoteMention?: TaskNoteMentionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskNoteMentionUpsertWithWhereUniqueWithoutNoteInput = {
    where: TaskNoteMentionWhereUniqueInput
    update: XOR<TaskNoteMentionUpdateWithoutNoteInput, TaskNoteMentionUncheckedUpdateWithoutNoteInput>
    create: XOR<TaskNoteMentionCreateWithoutNoteInput, TaskNoteMentionUncheckedCreateWithoutNoteInput>
  }

  export type TaskNoteMentionUpdateWithWhereUniqueWithoutNoteInput = {
    where: TaskNoteMentionWhereUniqueInput
    data: XOR<TaskNoteMentionUpdateWithoutNoteInput, TaskNoteMentionUncheckedUpdateWithoutNoteInput>
  }

  export type TaskNoteMentionUpdateManyWithWhereWithoutNoteInput = {
    where: TaskNoteMentionScalarWhereInput
    data: XOR<TaskNoteMentionUpdateManyMutationInput, TaskNoteMentionUncheckedUpdateManyWithoutNoteInput>
  }

  export type TaskNoteCreateWithoutMentionsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type TaskNoteUncheckedCreateWithoutMentionsInput = {
    id?: string
    taskId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskNoteCreateOrConnectWithoutMentionsInput = {
    where: TaskNoteWhereUniqueInput
    create: XOR<TaskNoteCreateWithoutMentionsInput, TaskNoteUncheckedCreateWithoutMentionsInput>
  }

  export type UserCreateWithoutTaskNoteMentionInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    notes?: TaskNoteCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskNoteMentionInput = {
    id?: string
    email?: string | null
    handle: string
    name?: string | null
    createdAt?: Date | string
    googleEmail?: string | null
    googleRefreshToken?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutAuthorInput
    TaskAssignment?: TaskAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskNoteMentionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskNoteMentionInput, UserUncheckedCreateWithoutTaskNoteMentionInput>
  }

  export type TaskNoteUpsertWithoutMentionsInput = {
    update: XOR<TaskNoteUpdateWithoutMentionsInput, TaskNoteUncheckedUpdateWithoutMentionsInput>
    create: XOR<TaskNoteCreateWithoutMentionsInput, TaskNoteUncheckedCreateWithoutMentionsInput>
    where?: TaskNoteWhereInput
  }

  export type TaskNoteUpdateToOneWithWhereWithoutMentionsInput = {
    where?: TaskNoteWhereInput
    data: XOR<TaskNoteUpdateWithoutMentionsInput, TaskNoteUncheckedUpdateWithoutMentionsInput>
  }

  export type TaskNoteUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type TaskNoteUncheckedUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTaskNoteMentionInput = {
    update: XOR<UserUpdateWithoutTaskNoteMentionInput, UserUncheckedUpdateWithoutTaskNoteMentionInput>
    create: XOR<UserCreateWithoutTaskNoteMentionInput, UserUncheckedCreateWithoutTaskNoteMentionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskNoteMentionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskNoteMentionInput, UserUncheckedUpdateWithoutTaskNoteMentionInput>
  }

  export type UserUpdateWithoutTaskNoteMentionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskNoteMentionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutAuthorNestedInput
    TaskAssignment?: TaskAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutEventsInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    org: OrganizationCreateNestedOneWithoutTeamsInput
    memberships?: TeamMembershipCreateNestedManyWithoutTeamInput
    goals?: GoalCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeCreateNestedManyWithoutTeamInput
    links?: TeamLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutEventsInput = {
    id?: string
    orgId: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
    memberships?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    goals?: GoalUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    joinCodes?: TeamJoinCodeUncheckedCreateNestedManyWithoutTeamInput
    links?: TeamLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutEventsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutEventsInput, TeamUncheckedCreateWithoutEventsInput>
  }

  export type TaskCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTasksInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    assignees?: TaskAssignmentCreateNestedManyWithoutTaskInput
    notes?: TaskNoteCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    teamId: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    assignees?: TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    notes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCalendarEventsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCalendarEventsInput, TaskUncheckedCreateWithoutCalendarEventsInput>
  }

  export type TeamUpsertWithoutEventsInput = {
    update: XOR<TeamUpdateWithoutEventsInput, TeamUncheckedUpdateWithoutEventsInput>
    create: XOR<TeamCreateWithoutEventsInput, TeamUncheckedCreateWithoutEventsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutEventsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutEventsInput, TeamUncheckedUpdateWithoutEventsInput>
  }

  export type TeamUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TaskUpsertWithoutCalendarEventsInput = {
    update: XOR<TaskUpdateWithoutCalendarEventsInput, TaskUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<TaskCreateWithoutCalendarEventsInput, TaskUncheckedCreateWithoutCalendarEventsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCalendarEventsInput, TaskUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type TaskUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type IdentityCreateManyUserInput = {
    id?: string
    provider: string
    providerId: string
  }

  export type OrgMembershipCreateManyUserInput = {
    id?: string
    orgId: string
    role: $Enums.OrgRole
  }

  export type TeamMembershipCreateManyUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
  }

  export type TaskNoteCreateManyAuthorInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
  }

  export type TaskAssignmentCreateManyUserInput = {
    id?: string
    taskId: string
  }

  export type TaskNoteMentionCreateManyUserInput = {
    id?: string
    noteId: string
  }

  export type IdentityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type IdentityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type IdentityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrgMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    org?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type OrgMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type OrgMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type TeamMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    team?: TeamUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TeamMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TaskNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutNotesNestedInput
    mentions?: TaskNoteMentionUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: TaskNoteMentionUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteMentionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: TaskNoteUpdateOneRequiredWithoutMentionsNestedInput
  }

  export type TaskNoteMentionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteMentionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
  }

  export type OrgMembershipCreateManyOrgInput = {
    id?: string
    userId: string
    role: $Enums.OrgRole
  }

  export type TeamCreateManyOrgInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    info?: string | null
  }

  export type OrgJoinCodeCreateManyOrgInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
    createdAt?: Date | string
  }

  export type OrgMembershipUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type OrgMembershipUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type OrgMembershipUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
  }

  export type TeamUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUpdateManyWithoutTeamNestedInput
    goals?: GoalUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    goals?: GoalUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutTeamNestedInput
    joinCodes?: TeamJoinCodeUncheckedUpdateManyWithoutTeamNestedInput
    links?: TeamLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrgJoinCodeUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgJoinCodeUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgJoinCodeUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMembershipCreateManyTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
  }

  export type GoalCreateManyTeamInput = {
    id?: string
    title: string
    description?: string | null
    dueDate?: Date | string | null
    status?: string
  }

  export type TaskCreateManyTeamInput = {
    id?: string
    goalId?: string | null
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type CalendarEventCreateManyTeamInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
    relatedTaskId?: string | null
  }

  export type TeamJoinCodeCreateManyTeamInput = {
    id?: string
    code: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    uses?: number
  }

  export type TeamLinkCreateManyTeamInput = {
    id?: string
    label: string
    url: string
    ordinal?: number
  }

  export type TeamMembershipUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type TeamMembershipUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
  }

  export type GoalUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneWithoutCalendarEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamJoinCodeUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type TeamJoinCodeUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type TeamJoinCodeUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLinkUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLinkUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLinkUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ordinal?: IntFieldUpdateOperationsInput | number
  }

  export type TaskCreateManyGoalInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TaskUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    assignees?: TaskAssignmentUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    notes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyTaskInput = {
    id?: string
    userId: string
  }

  export type TaskNoteCreateManyTaskInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type CalendarEventCreateManyTaskInput = {
    id?: string
    teamId: string
    title: string
    description?: string | null
    type?: $Enums.CalendarItemType
    startAt: Date | string
    endAt: Date | string
    googleEventId?: string | null
    googleCalendarId?: string | null
    syncedAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type TaskAssignmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTaskAssignmentNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    mentions?: TaskNoteMentionUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: TaskNoteMentionUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type TaskNoteUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCalendarItemTypeFieldUpdateOperationsInput | $Enums.CalendarItemType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteMentionCreateManyNoteInput = {
    id?: string
    userId: string
  }

  export type TaskNoteMentionUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTaskNoteMentionNestedInput
  }

  export type TaskNoteMentionUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskNoteMentionUncheckedUpdateManyWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}